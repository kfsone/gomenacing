// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace ettuschema
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

/// Commodity is a type of item that can be traded within the game. At the moment,
/// the categories are small enough I decided to just enumerate them right here.
public struct Commodity : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static Commodity GetRootAsCommodity(ByteBuffer _bb) { return GetRootAsCommodity(_bb, new Commodity()); }
  public static Commodity GetRootAsCommodity(ByteBuffer _bb, Commodity obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Commodity __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Elite Dangerous' internal ID for the commodity acts as the key.
  public ulong CommodityId { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateCommodityId(ulong commodity_id) { int o = __p.__offset(4); if (o != 0) { __p.bb.PutUlong(o + __p.bb_pos, commodity_id); return true; } else { return false; } }
  /// Name can be localized as long as the English name is preserved for hashing.
  public string Name { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(6); }
  /// What type of item is this.
  public ettuschema.CommodityType CategoryId { get { int o = __p.__offset(8); return o != 0 ? (ettuschema.CommodityType)__p.bb.GetSbyte(o + __p.bb_pos) : ettuschema.CommodityType.None; } }
  public bool MutateCategoryId(ettuschema.CommodityType category_id) { int o = __p.__offset(8); if (o != 0) { __p.bb.PutSbyte(o + __p.bb_pos, (sbyte)category_id); return true; } else { return false; } }
  /// Whether the item is known to be rare.
  public bool IsRare { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool MutateIsRare(bool is_rare) { int o = __p.__offset(10); if (o != 0) { __p.bb.Put(o + __p.bb_pos, (byte)(is_rare ? 1 : 0)); return true; } else { return false; } }
  /// Whether the item is known to be marketable.
  public bool IsNonMarketable { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool MutateIsNonMarketable(bool is_non_marketable) { int o = __p.__offset(12); if (o != 0) { __p.bb.Put(o + __p.bb_pos, (byte)(is_non_marketable ? 1 : 0)); return true; } else { return false; } }
  /// The average galactic market price in credits.
  public uint AverageCr { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public bool MutateAverageCr(uint average_cr) { int o = __p.__offset(14); if (o != 0) { __p.bb.PutUint(o + __p.bb_pos, average_cr); return true; } else { return false; } }

  public static Offset<ettuschema.Commodity> CreateCommodity(FlatBufferBuilder builder,
      ulong commodity_id = 0,
      StringOffset nameOffset = default(StringOffset),
      ettuschema.CommodityType category_id = ettuschema.CommodityType.None,
      bool is_rare = false,
      bool is_non_marketable = false,
      uint average_cr = 0) {
    builder.StartTable(6);
    Commodity.AddCommodityId(builder, commodity_id);
    Commodity.AddAverageCr(builder, average_cr);
    Commodity.AddName(builder, nameOffset);
    Commodity.AddIsNonMarketable(builder, is_non_marketable);
    Commodity.AddIsRare(builder, is_rare);
    Commodity.AddCategoryId(builder, category_id);
    return Commodity.EndCommodity(builder);
  }

  public static void StartCommodity(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddCommodityId(FlatBufferBuilder builder, ulong commodityId) { builder.AddUlong(0, commodityId, 0); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(1, nameOffset.Value, 0); }
  public static void AddCategoryId(FlatBufferBuilder builder, ettuschema.CommodityType categoryId) { builder.AddSbyte(2, (sbyte)categoryId, 0); }
  public static void AddIsRare(FlatBufferBuilder builder, bool isRare) { builder.AddBool(3, isRare, false); }
  public static void AddIsNonMarketable(FlatBufferBuilder builder, bool isNonMarketable) { builder.AddBool(4, isNonMarketable, false); }
  public static void AddAverageCr(FlatBufferBuilder builder, uint averageCr) { builder.AddUint(5, averageCr, 0); }
  public static Offset<ettuschema.Commodity> EndCommodity(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<ettuschema.Commodity>(o);
  }

  public static VectorOffset CreateSortedVectorOfCommodity(FlatBufferBuilder builder, Offset<Commodity>[] offsets) {
    Array.Sort(offsets, (Offset<Commodity> o1, Offset<Commodity> o2) => builder.DataBuffer.GetUlong(Table.__offset(4, o1.Value, builder.DataBuffer)).CompareTo(builder.DataBuffer.GetUlong(Table.__offset(4, o2.Value, builder.DataBuffer))));
    return builder.CreateVectorOfTables(offsets);
  }

  public static Commodity? __lookup_by_key(int vectorLocation, ulong key, ByteBuffer bb) {
    int span = bb.GetInt(vectorLocation - 4);
    int start = 0;
    while (span != 0) {
      int middle = span / 2;
      int tableOffset = Table.__indirect(vectorLocation + 4 * (start + middle), bb);
      int comp = bb.GetUlong(Table.__offset(4, bb.Length - tableOffset, bb)).CompareTo(key);
      if (comp > 0) {
        span = middle;
      } else if (comp < 0) {
        middle++;
        start += middle;
        span -= middle;
      } else {
        return new Commodity().__assign(tableOffset, bb);
      }
    }
    return null;
  }
};


}
