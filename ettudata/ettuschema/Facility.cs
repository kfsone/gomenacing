// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace ettuschema
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

/// Facility represents a static, dockable entity within the game such as a station or planetary base.
/// Instead of assigning stations their own unique IDs, we produce an fnv1a_32 hash of the system name
/// and the station name.
public struct Facility : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_1_12_0(); }
  public static Facility GetRootAsFacility(ByteBuffer _bb) { return GetRootAsFacility(_bb, new Facility()); }
  public static Facility GetRootAsFacility(ByteBuffer _bb, Facility obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Facility __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// "{upper system name}@{facility name upper}"
  public uint FacilityId { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public bool MutateFacilityId(uint facility_id) { int o = __p.__offset(4); if (o != 0) { __p.bb.PutUint(o + __p.bb_pos, facility_id); return true; } else { return false; } }
  /// Hash of the all-upper name of the system.
  public uint SystemId { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public bool MutateSystemId(uint system_id) { int o = __p.__offset(6); if (o != 0) { __p.bb.PutUint(o + __p.bb_pos, system_id); return true; } else { return false; } }
  /// Name of the facility itself.
  public string Name { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(8); }
  /// Unix timestamp UTC of last update.
  public ulong TimestampUtc { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateTimestampUtc(ulong timestamp_utc) { int o = __p.__offset(10); if (o != 0) { __p.bb.PutUlong(o + __p.bb_pos, timestamp_utc); return true; } else { return false; } }
  /// Optional facility type.
  public ettuschema.FacilityType FacilityType { get { int o = __p.__offset(12); return o != 0 ? (ettuschema.FacilityType)__p.bb.GetSbyte(o + __p.bb_pos) : ettuschema.FacilityType.None; } }
  public bool MutateFacilityType(ettuschema.FacilityType facility_type) { int o = __p.__offset(12); if (o != 0) { __p.bb.PutSbyte(o + __p.bb_pos, (sbyte)facility_type); return true; } else { return false; } }
  /// Does it have an accessible trade market.
  public bool HasMarket { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)true; } }
  public bool MutateHasMarket(bool has_market) { int o = __p.__offset(14); if (o != 0) { __p.bb.Put(o + __p.bb_pos, (byte)(has_market ? 1 : 0)); return true; } else { return false; } }
  /// Does it have a black market.
  public bool HasBlackMarket { get { int o = __p.__offset(16); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool MutateHasBlackMarket(bool has_black_market) { int o = __p.__offset(16); if (o != 0) { __p.bb.Put(o + __p.bb_pos, (byte)(has_black_market ? 1 : 0)); return true; } else { return false; } }
  /// Can it refuel.
  public bool HasRefuel { get { int o = __p.__offset(18); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)true; } }
  public bool MutateHasRefuel(bool has_refuel) { int o = __p.__offset(18); if (o != 0) { __p.bb.Put(o + __p.bb_pos, (byte)(has_refuel ? 1 : 0)); return true; } else { return false; } }
  /// Can it repair.
  public bool HasRepair { get { int o = __p.__offset(20); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)true; } }
  public bool MutateHasRepair(bool has_repair) { int o = __p.__offset(20); if (o != 0) { __p.bb.Put(o + __p.bb_pos, (byte)(has_repair ? 1 : 0)); return true; } else { return false; } }
  /// Can it re-arm.
  public bool HasRearm { get { int o = __p.__offset(22); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)true; } }
  public bool MutateHasRearm(bool has_rearm) { int o = __p.__offset(22); if (o != 0) { __p.bb.Put(o + __p.bb_pos, (byte)(has_rearm ? 1 : 0)); return true; } else { return false; } }
  /// Does it sell/upgrade ship components.
  public bool HasOutfitting { get { int o = __p.__offset(24); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)true; } }
  public bool MutateHasOutfitting(bool has_outfitting) { int o = __p.__offset(24); if (o != 0) { __p.bb.Put(o + __p.bb_pos, (byte)(has_outfitting ? 1 : 0)); return true; } else { return false; } }
  /// Can you buy ships here.
  public bool HasShipyard { get { int o = __p.__offset(26); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool MutateHasShipyard(bool has_shipyard) { int o = __p.__offset(26); if (o != 0) { __p.bb.Put(o + __p.bb_pos, (byte)(has_shipyard ? 1 : 0)); return true; } else { return false; } }
  /// Can you dock here (this is taken from EDDB and might be redundant).
  public bool HasDocking { get { int o = __p.__offset(28); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)true; } }
  public bool MutateHasDocking(bool has_docking) { int o = __p.__offset(28); if (o != 0) { __p.bb.Put(o + __p.bb_pos, (byte)(has_docking ? 1 : 0)); return true; } else { return false; } }
  /// Does the market have regular trading commodities available.
  public bool HasCommodities { get { int o = __p.__offset(30); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)true; } }
  public bool MutateHasCommodities(bool has_commodities) { int o = __p.__offset(30); if (o != 0) { __p.bb.Put(o + __p.bb_pos, (byte)(has_commodities ? 1 : 0)); return true; } else { return false; } }
  /// Is it on a planet.
  public bool IsPlanetary { get { int o = __p.__offset(32); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool MutateIsPlanetary(bool is_planetary) { int o = __p.__offset(32); if (o != 0) { __p.bb.Put(o + __p.bb_pos, (byte)(is_planetary ? 1 : 0)); return true; } else { return false; } }
  /// Distance from the facility to the entry point in the system.
  public uint LsToStar { get { int o = __p.__offset(34); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public bool MutateLsToStar(uint ls_to_star) { int o = __p.__offset(34); if (o != 0) { __p.bb.PutUint(o + __p.bb_pos, ls_to_star); return true; } else { return false; } }
  /// The governance of this station. If not present, assume system's government.
  public ettuschema.Government Government { get { int o = __p.__offset(36); return o != 0 ? (ettuschema.Government)__p.bb.GetSbyte(o + __p.bb_pos) : ettuschema.Government.Corporate; } }
  public bool MutateGovernment(ettuschema.Government government) { int o = __p.__offset(36); if (o != 0) { __p.bb.PutSbyte(o + __p.bb_pos, (sbyte)government); return true; } else { return false; } }
  /// The allegiance of this station. If not present, assume system's allegiance.
  public ettuschema.Allegiance Allegiance { get { int o = __p.__offset(38); return o != 0 ? (ettuschema.Allegiance)__p.bb.GetSbyte(o + __p.bb_pos) : ettuschema.Allegiance.Independent; } }
  public bool MutateAllegiance(ettuschema.Allegiance allegiance) { int o = __p.__offset(38); if (o != 0) { __p.bb.PutSbyte(o + __p.bb_pos, (sbyte)allegiance); return true; } else { return false; } }
  /// Presumably the internal ED identifier for the market here.
  public ulong EdMarketId { get { int o = __p.__offset(40); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }
  public bool MutateEdMarketId(ulong ed_market_id) { int o = __p.__offset(40); if (o != 0) { __p.bb.PutUlong(o + __p.bb_pos, ed_market_id); return true; } else { return false; } }

  public static Offset<ettuschema.Facility> CreateFacility(FlatBufferBuilder builder,
      uint facility_id = 0,
      uint system_id = 0,
      StringOffset nameOffset = default(StringOffset),
      ulong timestamp_utc = 0,
      ettuschema.FacilityType facility_type = ettuschema.FacilityType.None,
      bool has_market = true,
      bool has_black_market = false,
      bool has_refuel = true,
      bool has_repair = true,
      bool has_rearm = true,
      bool has_outfitting = true,
      bool has_shipyard = false,
      bool has_docking = true,
      bool has_commodities = true,
      bool is_planetary = false,
      uint ls_to_star = 0,
      ettuschema.Government government = ettuschema.Government.Corporate,
      ettuschema.Allegiance allegiance = ettuschema.Allegiance.Independent,
      ulong ed_market_id = 0) {
    builder.StartTable(19);
    Facility.AddEdMarketId(builder, ed_market_id);
    Facility.AddTimestampUtc(builder, timestamp_utc);
    Facility.AddLsToStar(builder, ls_to_star);
    Facility.AddName(builder, nameOffset);
    Facility.AddSystemId(builder, system_id);
    Facility.AddFacilityId(builder, facility_id);
    Facility.AddAllegiance(builder, allegiance);
    Facility.AddGovernment(builder, government);
    Facility.AddIsPlanetary(builder, is_planetary);
    Facility.AddHasCommodities(builder, has_commodities);
    Facility.AddHasDocking(builder, has_docking);
    Facility.AddHasShipyard(builder, has_shipyard);
    Facility.AddHasOutfitting(builder, has_outfitting);
    Facility.AddHasRearm(builder, has_rearm);
    Facility.AddHasRepair(builder, has_repair);
    Facility.AddHasRefuel(builder, has_refuel);
    Facility.AddHasBlackMarket(builder, has_black_market);
    Facility.AddHasMarket(builder, has_market);
    Facility.AddFacilityType(builder, facility_type);
    return Facility.EndFacility(builder);
  }

  public static void StartFacility(FlatBufferBuilder builder) { builder.StartTable(19); }
  public static void AddFacilityId(FlatBufferBuilder builder, uint facilityId) { builder.AddUint(0, facilityId, 0); }
  public static void AddSystemId(FlatBufferBuilder builder, uint systemId) { builder.AddUint(1, systemId, 0); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(2, nameOffset.Value, 0); }
  public static void AddTimestampUtc(FlatBufferBuilder builder, ulong timestampUtc) { builder.AddUlong(3, timestampUtc, 0); }
  public static void AddFacilityType(FlatBufferBuilder builder, ettuschema.FacilityType facilityType) { builder.AddSbyte(4, (sbyte)facilityType, 0); }
  public static void AddHasMarket(FlatBufferBuilder builder, bool hasMarket) { builder.AddBool(5, hasMarket, true); }
  public static void AddHasBlackMarket(FlatBufferBuilder builder, bool hasBlackMarket) { builder.AddBool(6, hasBlackMarket, false); }
  public static void AddHasRefuel(FlatBufferBuilder builder, bool hasRefuel) { builder.AddBool(7, hasRefuel, true); }
  public static void AddHasRepair(FlatBufferBuilder builder, bool hasRepair) { builder.AddBool(8, hasRepair, true); }
  public static void AddHasRearm(FlatBufferBuilder builder, bool hasRearm) { builder.AddBool(9, hasRearm, true); }
  public static void AddHasOutfitting(FlatBufferBuilder builder, bool hasOutfitting) { builder.AddBool(10, hasOutfitting, true); }
  public static void AddHasShipyard(FlatBufferBuilder builder, bool hasShipyard) { builder.AddBool(11, hasShipyard, false); }
  public static void AddHasDocking(FlatBufferBuilder builder, bool hasDocking) { builder.AddBool(12, hasDocking, true); }
  public static void AddHasCommodities(FlatBufferBuilder builder, bool hasCommodities) { builder.AddBool(13, hasCommodities, true); }
  public static void AddIsPlanetary(FlatBufferBuilder builder, bool isPlanetary) { builder.AddBool(14, isPlanetary, false); }
  public static void AddLsToStar(FlatBufferBuilder builder, uint lsToStar) { builder.AddUint(15, lsToStar, 0); }
  public static void AddGovernment(FlatBufferBuilder builder, ettuschema.Government government) { builder.AddSbyte(16, (sbyte)government, 5); }
  public static void AddAllegiance(FlatBufferBuilder builder, ettuschema.Allegiance allegiance) { builder.AddSbyte(17, (sbyte)allegiance, 4); }
  public static void AddEdMarketId(FlatBufferBuilder builder, ulong edMarketId) { builder.AddUlong(18, edMarketId, 0); }
  public static Offset<ettuschema.Facility> EndFacility(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<ettuschema.Facility>(o);
  }

  public static VectorOffset CreateSortedVectorOfFacility(FlatBufferBuilder builder, Offset<Facility>[] offsets) {
    Array.Sort(offsets, (Offset<Facility> o1, Offset<Facility> o2) => builder.DataBuffer.GetUint(Table.__offset(4, o1.Value, builder.DataBuffer)).CompareTo(builder.DataBuffer.GetUint(Table.__offset(4, o2.Value, builder.DataBuffer))));
    return builder.CreateVectorOfTables(offsets);
  }

  public static Facility? __lookup_by_key(int vectorLocation, uint key, ByteBuffer bb) {
    int span = bb.GetInt(vectorLocation - 4);
    int start = 0;
    while (span != 0) {
      int middle = span / 2;
      int tableOffset = Table.__indirect(vectorLocation + 4 * (start + middle), bb);
      int comp = bb.GetUint(Table.__offset(4, bb.Length - tableOffset, bb)).CompareTo(key);
      if (comp > 0) {
        span = middle;
      } else if (comp < 0) {
        middle++;
        start += middle;
        span -= middle;
      } else {
        return new Facility().__assign(tableOffset, bb);
      }
    }
    return null;
  }
};


}
