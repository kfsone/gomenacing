// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod gomschema {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

/// Government is an enumeration of government types reduced to a single field.
#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Government {
  None = 0,
  Anarchy = 1,
  Communism = 2,
  Confederacy = 3,
  ooperative = 4,
  Corporate = 5,
  emocracy = 6,
  Dictatorship = 7,
  Feudal = 8,
  Patronage = 9,
  Prison = 10,
  PrisonColony = 11,
  Theocracy = 12,

}

const ENUM_MIN_GOVERNMENT: i8 = 0;
const ENUM_MAX_GOVERNMENT: i8 = 12;

impl<'a> flatbuffers::Follow<'a> for Government {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Government {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const Government;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const Government;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Government {
    type Output = Government;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Government>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_GOVERNMENT:[Government; 13] = [
  Government::None,
  Government::Anarchy,
  Government::Communism,
  Government::Confederacy,
  Government::ooperative,
  Government::Corporate,
  Government::emocracy,
  Government::Dictatorship,
  Government::Feudal,
  Government::Patronage,
  Government::Prison,
  Government::PrisonColony,
  Government::Theocracy
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_GOVERNMENT:[&'static str; 13] = [
    "None",
    "Anarchy",
    "Communism",
    "Confederacy",
    "ooperative",
    "Corporate",
    "emocracy",
    "Dictatorship",
    "Feudal",
    "Patronage",
    "Prison",
    "PrisonColony",
    "Theocracy"
];

pub fn enum_name_government(e: Government) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_GOVERNMENT[index as usize]
}

/// Allegiance is an enumeration of allegiance types reduced to a single field.
#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Allegiance {
  None = 0,
  Alliance = 1,
  Empire = 2,
  Federation = 3,
  Independent = 4,
  PilotsFederation = 5,

}

const ENUM_MIN_ALLEGIANCE: i8 = 0;
const ENUM_MAX_ALLEGIANCE: i8 = 5;

impl<'a> flatbuffers::Follow<'a> for Allegiance {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Allegiance {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const Allegiance;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const Allegiance;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Allegiance {
    type Output = Allegiance;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Allegiance>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_ALLEGIANCE:[Allegiance; 6] = [
  Allegiance::None,
  Allegiance::Alliance,
  Allegiance::Empire,
  Allegiance::Federation,
  Allegiance::Independent,
  Allegiance::PilotsFederation
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_ALLEGIANCE:[&'static str; 6] = [
    "None",
    "Alliance",
    "Empire",
    "Federation",
    "Independent",
    "PilotsFederation"
];

pub fn enum_name_allegiance(e: Allegiance) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_ALLEGIANCE[index as usize]
}

/// Security level is system-specific and determines how aggressive law enforcement is.
#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum SecurityLevel {
  None = 0,
  Anarchy = 1,
  Low = 2,
  Medium = 3,
  High = 4,

}

const ENUM_MIN_SECURITY_LEVEL: i8 = 0;
const ENUM_MAX_SECURITY_LEVEL: i8 = 4;

impl<'a> flatbuffers::Follow<'a> for SecurityLevel {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for SecurityLevel {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const SecurityLevel;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const SecurityLevel;
    unsafe { *p }
  }
}

impl flatbuffers::Push for SecurityLevel {
    type Output = SecurityLevel;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<SecurityLevel>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_SECURITY_LEVEL:[SecurityLevel; 5] = [
  SecurityLevel::None,
  SecurityLevel::Anarchy,
  SecurityLevel::Low,
  SecurityLevel::Medium,
  SecurityLevel::High
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_SECURITY_LEVEL:[&'static str; 5] = [
    "None",
    "Anarchy",
    "Low",
    "Medium",
    "High"
];

pub fn enum_name_security_level(e: SecurityLevel) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_SECURITY_LEVEL[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FacilityType {
  None = 0,
  CivilianOutpost = 1,
  CommercialOutpost = 2,
  CoriolisStarport = 3,
  IndustrialOutpost = 4,
  MilitaryOutpost = 5,
  MiningOutpost = 6,
  OcellusStarport = 7,
  OrbisStarport = 8,
  ScientificOutpost = 9,
  PlanetaryOutpost = 10,
  PlanetaryPort = 11,
  PlanetarySettlement = 12,
  Megaship = 13,
  AsteroidBase = 14,
  FleetCarrier = 15,

}

const ENUM_MIN_FACILITY_TYPE: i8 = 0;
const ENUM_MAX_FACILITY_TYPE: i8 = 15;

impl<'a> flatbuffers::Follow<'a> for FacilityType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FacilityType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const FacilityType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const FacilityType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FacilityType {
    type Output = FacilityType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FacilityType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_FACILITY_TYPE:[FacilityType; 16] = [
  FacilityType::None,
  FacilityType::CivilianOutpost,
  FacilityType::CommercialOutpost,
  FacilityType::CoriolisStarport,
  FacilityType::IndustrialOutpost,
  FacilityType::MilitaryOutpost,
  FacilityType::MiningOutpost,
  FacilityType::OcellusStarport,
  FacilityType::OrbisStarport,
  FacilityType::ScientificOutpost,
  FacilityType::PlanetaryOutpost,
  FacilityType::PlanetaryPort,
  FacilityType::PlanetarySettlement,
  FacilityType::Megaship,
  FacilityType::AsteroidBase,
  FacilityType::FleetCarrier
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_FACILITY_TYPE:[&'static str; 16] = [
    "None",
    "CivilianOutpost",
    "CommercialOutpost",
    "CoriolisStarport",
    "IndustrialOutpost",
    "MilitaryOutpost",
    "MiningOutpost",
    "OcellusStarport",
    "OrbisStarport",
    "ScientificOutpost",
    "PlanetaryOutpost",
    "PlanetaryPort",
    "PlanetarySettlement",
    "Megaship",
    "AsteroidBase",
    "FleetCarrier"
];

pub fn enum_name_facility_type(e: FacilityType) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_FACILITY_TYPE[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum LandingPad {
  None = 0,
  Small = 1,
  Medium = 2,
  Large = 3,

}

const ENUM_MIN_LANDING_PAD: i8 = 0;
const ENUM_MAX_LANDING_PAD: i8 = 3;

impl<'a> flatbuffers::Follow<'a> for LandingPad {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for LandingPad {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const LandingPad;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const LandingPad;
    unsafe { *p }
  }
}

impl flatbuffers::Push for LandingPad {
    type Output = LandingPad;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<LandingPad>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_LANDING_PAD:[LandingPad; 4] = [
  LandingPad::None,
  LandingPad::Small,
  LandingPad::Medium,
  LandingPad::Large
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_LANDING_PAD:[&'static str; 4] = [
    "None",
    "Small",
    "Medium",
    "Large"
];

pub fn enum_name_landing_pad(e: LandingPad) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_LANDING_PAD[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum CommodityType {
  None = 0,
  Chemicals = 1,
  ConsumerItems = 2,
  LegalDrugs = 3,
  Foods = 4,
  IndustrialMaterials = 5,
  Machinery = 6,
  Medicines = 7,
  Metals = 8,
  Minerals = 9,
  Slavery = 10,
  Technology = 11,
  Textiles = 12,
  Waste = 13,
  Weapons = 14,
  Unknown = 15,
  Salvage = 16,

}

const ENUM_MIN_COMMODITY_TYPE: i8 = 0;
const ENUM_MAX_COMMODITY_TYPE: i8 = 16;

impl<'a> flatbuffers::Follow<'a> for CommodityType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for CommodityType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const CommodityType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const CommodityType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for CommodityType {
    type Output = CommodityType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<CommodityType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_COMMODITY_TYPE:[CommodityType; 17] = [
  CommodityType::None,
  CommodityType::Chemicals,
  CommodityType::ConsumerItems,
  CommodityType::LegalDrugs,
  CommodityType::Foods,
  CommodityType::IndustrialMaterials,
  CommodityType::Machinery,
  CommodityType::Medicines,
  CommodityType::Metals,
  CommodityType::Minerals,
  CommodityType::Slavery,
  CommodityType::Technology,
  CommodityType::Textiles,
  CommodityType::Waste,
  CommodityType::Weapons,
  CommodityType::Unknown,
  CommodityType::Salvage
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_COMMODITY_TYPE:[&'static str; 17] = [
    "None",
    "Chemicals",
    "ConsumerItems",
    "LegalDrugs",
    "Foods",
    "IndustrialMaterials",
    "Machinery",
    "Medicines",
    "Metals",
    "Minerals",
    "Slavery",
    "Technology",
    "Textiles",
    "Waste",
    "Weapons",
    "Unknown",
    "Salvage"
];

pub fn enum_name_commodity_type(e: CommodityType) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_COMMODITY_TYPE[index as usize]
}

/// Trade is a discrete entry for a Commodity that is or can be traded at with
/// a number of units and a value.
// struct Trade, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Trade {
  commodity_id_: u64,
  units_: u32,
  credits_: u16,
  padding0__: u16,
  timestamp_utc_: u64,
} // pub struct Trade
impl flatbuffers::SafeSliceAccess for Trade {}
impl<'a> flatbuffers::Follow<'a> for Trade {
  type Inner = &'a Trade;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Trade>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Trade {
  type Inner = &'a Trade;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Trade>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Trade {
    type Output = Trade;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Trade as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Trade {
    type Output = Trade;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Trade as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Trade {
  pub fn new<'a>(_commodity_id: u64, _units: u32, _credits: u16, _timestamp_utc: u64) -> Self {
    Trade {
      commodity_id_: _commodity_id.to_little_endian(),
      units_: _units.to_little_endian(),
      credits_: _credits.to_little_endian(),
      timestamp_utc_: _timestamp_utc.to_little_endian(),

      padding0__: 0,
    }
  }
  /// Which commodity this descrbes.
  pub fn commodity_id<'a>(&'a self) -> u64 {
    self.commodity_id_.from_little_endian()
  }
  /// How many units
  pub fn units<'a>(&'a self) -> u32 {
    self.units_.from_little_endian()
  }
  /// How many credits
  pub fn credits<'a>(&'a self) -> u16 {
    self.credits_.from_little_endian()
  }
  /// Unix timestamp UTC.
  pub fn timestamp_utc<'a>(&'a self) -> u64 {
    self.timestamp_utc_.from_little_endian()
  }
}

/// Galactic coordinate for a system.
// struct Coordinate, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Coordinate {
  x_: f64,
  y_: f64,
  z_: f64,
} // pub struct Coordinate
impl flatbuffers::SafeSliceAccess for Coordinate {}
impl<'a> flatbuffers::Follow<'a> for Coordinate {
  type Inner = &'a Coordinate;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Coordinate>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Coordinate {
  type Inner = &'a Coordinate;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Coordinate>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Coordinate {
    type Output = Coordinate;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Coordinate as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Coordinate {
    type Output = Coordinate;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Coordinate as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Coordinate {
  pub fn new<'a>(_x: f64, _y: f64, _z: f64) -> Self {
    Coordinate {
      x_: _x.to_little_endian(),
      y_: _y.to_little_endian(),
      z_: _z.to_little_endian(),

    }
  }
  pub fn x<'a>(&'a self) -> f64 {
    self.x_.from_little_endian()
  }
  pub fn y<'a>(&'a self) -> f64 {
    self.y_.from_little_endian()
  }
  pub fn z<'a>(&'a self) -> f64 {
    self.z_.from_little_endian()
  }
}

pub enum CommodityOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

/// Commodity is a type of item that can be traded within the game. At the moment,
/// the categories are small enough I decided to just enumerate them right here.
pub struct Commodity<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Commodity<'a> {
    type Inner = Commodity<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Commodity<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Commodity {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CommodityArgs<'args>) -> flatbuffers::WIPOffset<Commodity<'bldr>> {
      let mut builder = CommodityBuilder::new(_fbb);
      builder.add_commodity_id(args.commodity_id);
      builder.add_average_cr(args.average_cr);
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_is_non_marketable(args.is_non_marketable);
      builder.add_is_rare(args.is_rare);
      builder.add_category_id(args.category_id);
      builder.finish()
    }

    pub const VT_COMMODITY_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_CATEGORY_ID: flatbuffers::VOffsetT = 8;
    pub const VT_IS_RARE: flatbuffers::VOffsetT = 10;
    pub const VT_IS_NON_MARKETABLE: flatbuffers::VOffsetT = 12;
    pub const VT_AVERAGE_CR: flatbuffers::VOffsetT = 14;

  /// Elite Dangerous' internal ID for the commodity acts as the key.
  #[inline]
  pub fn commodity_id(&self) -> u64 {
    self._tab.get::<u64>(Commodity::VT_COMMODITY_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Commodity) ->  bool {
    self.commodity_id() < o.commodity_id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) ->  ::std::cmp::Ordering {
    let key = self.commodity_id();
    key.cmp(&val)
  }
  /// Name can be localized as long as the English name is preserved for hashing.
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Commodity::VT_NAME, None)
  }
  /// What type of item is this.
  #[inline]
  pub fn category_id(&self) -> CommodityType {
    self._tab.get::<CommodityType>(Commodity::VT_CATEGORY_ID, Some(CommodityType::None)).unwrap()
  }
  /// Whether the item is known to be rare.
  #[inline]
  pub fn is_rare(&self) -> bool {
    self._tab.get::<bool>(Commodity::VT_IS_RARE, Some(false)).unwrap()
  }
  /// Whether the item is known to be marketable.
  #[inline]
  pub fn is_non_marketable(&self) -> bool {
    self._tab.get::<bool>(Commodity::VT_IS_NON_MARKETABLE, Some(false)).unwrap()
  }
  /// The average galactic market price in credits.
  #[inline]
  pub fn average_cr(&self) -> u32 {
    self._tab.get::<u32>(Commodity::VT_AVERAGE_CR, Some(0)).unwrap()
  }
}

pub struct CommodityArgs<'a> {
    pub commodity_id: u64,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub category_id: CommodityType,
    pub is_rare: bool,
    pub is_non_marketable: bool,
    pub average_cr: u32,
}
impl<'a> Default for CommodityArgs<'a> {
    #[inline]
    fn default() -> Self {
        CommodityArgs {
            commodity_id: 0,
            name: None,
            category_id: CommodityType::None,
            is_rare: false,
            is_non_marketable: false,
            average_cr: 0,
        }
    }
}
pub struct CommodityBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CommodityBuilder<'a, 'b> {
  #[inline]
  pub fn add_commodity_id(&mut self, commodity_id: u64) {
    self.fbb_.push_slot::<u64>(Commodity::VT_COMMODITY_ID, commodity_id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Commodity::VT_NAME, name);
  }
  #[inline]
  pub fn add_category_id(&mut self, category_id: CommodityType) {
    self.fbb_.push_slot::<CommodityType>(Commodity::VT_CATEGORY_ID, category_id, CommodityType::None);
  }
  #[inline]
  pub fn add_is_rare(&mut self, is_rare: bool) {
    self.fbb_.push_slot::<bool>(Commodity::VT_IS_RARE, is_rare, false);
  }
  #[inline]
  pub fn add_is_non_marketable(&mut self, is_non_marketable: bool) {
    self.fbb_.push_slot::<bool>(Commodity::VT_IS_NON_MARKETABLE, is_non_marketable, false);
  }
  #[inline]
  pub fn add_average_cr(&mut self, average_cr: u32) {
    self.fbb_.push_slot::<u32>(Commodity::VT_AVERAGE_CR, average_cr, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CommodityBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CommodityBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Commodity<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FacilityListingOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FacilityListing<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FacilityListing<'a> {
    type Inner = FacilityListing<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FacilityListing<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FacilityListing {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FacilityListingArgs<'args>) -> flatbuffers::WIPOffset<FacilityListing<'bldr>> {
      let mut builder = FacilityListingBuilder::new(_fbb);
      if let Some(x) = args.demand { builder.add_demand(x); }
      if let Some(x) = args.supply { builder.add_supply(x); }
      builder.add_facility_id(args.facility_id);
      builder.finish()
    }

    pub const VT_FACILITY_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SUPPLY: flatbuffers::VOffsetT = 6;
    pub const VT_DEMAND: flatbuffers::VOffsetT = 8;

  /// Identifies the facility presenting these trades.
  #[inline]
  pub fn facility_id(&self) -> u32 {
    self._tab.get::<u32>(FacilityListing::VT_FACILITY_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &FacilityListing) ->  bool {
    self.facility_id() < o.facility_id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u32) ->  ::std::cmp::Ordering {
    let key = self.facility_id();
    key.cmp(&val)
  }
  /// Commodities this facility sells.
  #[inline]
  pub fn supply(&self) -> Option<&'a [Trade]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Trade>>>(FacilityListing::VT_SUPPLY, None).map(|v| v.safe_slice() )
  }
  /// Commodities this facility buys.
  #[inline]
  pub fn demand(&self) -> Option<&'a [Trade]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Trade>>>(FacilityListing::VT_DEMAND, None).map(|v| v.safe_slice() )
  }
}

pub struct FacilityListingArgs<'a> {
    pub facility_id: u32,
    pub supply: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Trade>>>,
    pub demand: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Trade>>>,
}
impl<'a> Default for FacilityListingArgs<'a> {
    #[inline]
    fn default() -> Self {
        FacilityListingArgs {
            facility_id: 0,
            supply: None,
            demand: None,
        }
    }
}
pub struct FacilityListingBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FacilityListingBuilder<'a, 'b> {
  #[inline]
  pub fn add_facility_id(&mut self, facility_id: u32) {
    self.fbb_.push_slot::<u32>(FacilityListing::VT_FACILITY_ID, facility_id, 0);
  }
  #[inline]
  pub fn add_supply(&mut self, supply: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Trade>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FacilityListing::VT_SUPPLY, supply);
  }
  #[inline]
  pub fn add_demand(&mut self, demand: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Trade>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FacilityListing::VT_DEMAND, demand);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FacilityListingBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FacilityListingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FacilityListing<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FacilityOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

/// Facility represents a static, dockable entity within the game such as a station or planetary base.
/// Instead of assigning stations their own unique IDs, we produce an fnv1a_32 hash of the system name
/// and the station name.
pub struct Facility<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Facility<'a> {
    type Inner = Facility<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Facility<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Facility {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FacilityArgs<'args>) -> flatbuffers::WIPOffset<Facility<'bldr>> {
      let mut builder = FacilityBuilder::new(_fbb);
      builder.add_ed_market_id(args.ed_market_id);
      builder.add_timestamp_utc(args.timestamp_utc);
      builder.add_ls_to_star(args.ls_to_star);
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_system_id(args.system_id);
      builder.add_facility_id(args.facility_id);
      builder.add_allegiance(args.allegiance);
      builder.add_government(args.government);
      builder.add_is_planetary(args.is_planetary);
      builder.add_has_commodities(args.has_commodities);
      builder.add_has_docking(args.has_docking);
      builder.add_has_shipyard(args.has_shipyard);
      builder.add_has_outfitting(args.has_outfitting);
      builder.add_has_rearm(args.has_rearm);
      builder.add_has_repair(args.has_repair);
      builder.add_has_refuel(args.has_refuel);
      builder.add_has_black_market(args.has_black_market);
      builder.add_has_market(args.has_market);
      builder.add_facility_type(args.facility_type);
      builder.finish()
    }

    pub const VT_FACILITY_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SYSTEM_ID: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_TIMESTAMP_UTC: flatbuffers::VOffsetT = 10;
    pub const VT_FACILITY_TYPE: flatbuffers::VOffsetT = 12;
    pub const VT_HAS_MARKET: flatbuffers::VOffsetT = 14;
    pub const VT_HAS_BLACK_MARKET: flatbuffers::VOffsetT = 16;
    pub const VT_HAS_REFUEL: flatbuffers::VOffsetT = 18;
    pub const VT_HAS_REPAIR: flatbuffers::VOffsetT = 20;
    pub const VT_HAS_REARM: flatbuffers::VOffsetT = 22;
    pub const VT_HAS_OUTFITTING: flatbuffers::VOffsetT = 24;
    pub const VT_HAS_SHIPYARD: flatbuffers::VOffsetT = 26;
    pub const VT_HAS_DOCKING: flatbuffers::VOffsetT = 28;
    pub const VT_HAS_COMMODITIES: flatbuffers::VOffsetT = 30;
    pub const VT_IS_PLANETARY: flatbuffers::VOffsetT = 32;
    pub const VT_LS_TO_STAR: flatbuffers::VOffsetT = 34;
    pub const VT_GOVERNMENT: flatbuffers::VOffsetT = 36;
    pub const VT_ALLEGIANCE: flatbuffers::VOffsetT = 38;
    pub const VT_ED_MARKET_ID: flatbuffers::VOffsetT = 40;

  /// "{upper system name}@{facility name upper}"
  #[inline]
  pub fn facility_id(&self) -> u32 {
    self._tab.get::<u32>(Facility::VT_FACILITY_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Facility) ->  bool {
    self.facility_id() < o.facility_id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u32) ->  ::std::cmp::Ordering {
    let key = self.facility_id();
    key.cmp(&val)
  }
  /// Hash of the all-upper name of the system.
  #[inline]
  pub fn system_id(&self) -> u32 {
    self._tab.get::<u32>(Facility::VT_SYSTEM_ID, Some(0)).unwrap()
  }
  /// Name of the facility itself.
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Facility::VT_NAME, None)
  }
  /// Unix timestamp UTC of last update.
  #[inline]
  pub fn timestamp_utc(&self) -> u64 {
    self._tab.get::<u64>(Facility::VT_TIMESTAMP_UTC, Some(0)).unwrap()
  }
  /// Optional facility type.
  #[inline]
  pub fn facility_type(&self) -> FacilityType {
    self._tab.get::<FacilityType>(Facility::VT_FACILITY_TYPE, Some(FacilityType::None)).unwrap()
  }
  /// Does it have an accessible trade market.
  #[inline]
  pub fn has_market(&self) -> bool {
    self._tab.get::<bool>(Facility::VT_HAS_MARKET, Some(true)).unwrap()
  }
  /// Does it have a black market.
  #[inline]
  pub fn has_black_market(&self) -> bool {
    self._tab.get::<bool>(Facility::VT_HAS_BLACK_MARKET, Some(false)).unwrap()
  }
  /// Can it refuel.
  #[inline]
  pub fn has_refuel(&self) -> bool {
    self._tab.get::<bool>(Facility::VT_HAS_REFUEL, Some(true)).unwrap()
  }
  /// Can it repair.
  #[inline]
  pub fn has_repair(&self) -> bool {
    self._tab.get::<bool>(Facility::VT_HAS_REPAIR, Some(true)).unwrap()
  }
  /// Can it re-arm.
  #[inline]
  pub fn has_rearm(&self) -> bool {
    self._tab.get::<bool>(Facility::VT_HAS_REARM, Some(true)).unwrap()
  }
  /// Does it sell/upgrade ship components.
  #[inline]
  pub fn has_outfitting(&self) -> bool {
    self._tab.get::<bool>(Facility::VT_HAS_OUTFITTING, Some(true)).unwrap()
  }
  /// Can you buy ships here.
  #[inline]
  pub fn has_shipyard(&self) -> bool {
    self._tab.get::<bool>(Facility::VT_HAS_SHIPYARD, Some(false)).unwrap()
  }
  /// Can you dock here (this is taken from EDDB and might be redundant).
  #[inline]
  pub fn has_docking(&self) -> bool {
    self._tab.get::<bool>(Facility::VT_HAS_DOCKING, Some(true)).unwrap()
  }
  /// Does the market have regular trading commodities available.
  #[inline]
  pub fn has_commodities(&self) -> bool {
    self._tab.get::<bool>(Facility::VT_HAS_COMMODITIES, Some(true)).unwrap()
  }
  /// Is it on a planet.
  #[inline]
  pub fn is_planetary(&self) -> bool {
    self._tab.get::<bool>(Facility::VT_IS_PLANETARY, Some(false)).unwrap()
  }
  /// Distance from the facility to the entry point in the system.
  #[inline]
  pub fn ls_to_star(&self) -> u32 {
    self._tab.get::<u32>(Facility::VT_LS_TO_STAR, Some(0)).unwrap()
  }
  /// The governance of this station. If not present, assume system's government.
  #[inline]
  pub fn government(&self) -> Government {
    self._tab.get::<Government>(Facility::VT_GOVERNMENT, Some(Government::Corporate)).unwrap()
  }
  /// The allegiance of this station. If not present, assume system's allegiance.
  #[inline]
  pub fn allegiance(&self) -> Allegiance {
    self._tab.get::<Allegiance>(Facility::VT_ALLEGIANCE, Some(Allegiance::Independent)).unwrap()
  }
  /// Presumably the internal ED identifier for the market here.
  #[inline]
  pub fn ed_market_id(&self) -> u64 {
    self._tab.get::<u64>(Facility::VT_ED_MARKET_ID, Some(0)).unwrap()
  }
}

pub struct FacilityArgs<'a> {
    pub facility_id: u32,
    pub system_id: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub timestamp_utc: u64,
    pub facility_type: FacilityType,
    pub has_market: bool,
    pub has_black_market: bool,
    pub has_refuel: bool,
    pub has_repair: bool,
    pub has_rearm: bool,
    pub has_outfitting: bool,
    pub has_shipyard: bool,
    pub has_docking: bool,
    pub has_commodities: bool,
    pub is_planetary: bool,
    pub ls_to_star: u32,
    pub government: Government,
    pub allegiance: Allegiance,
    pub ed_market_id: u64,
}
impl<'a> Default for FacilityArgs<'a> {
    #[inline]
    fn default() -> Self {
        FacilityArgs {
            facility_id: 0,
            system_id: 0,
            name: None,
            timestamp_utc: 0,
            facility_type: FacilityType::None,
            has_market: true,
            has_black_market: false,
            has_refuel: true,
            has_repair: true,
            has_rearm: true,
            has_outfitting: true,
            has_shipyard: false,
            has_docking: true,
            has_commodities: true,
            is_planetary: false,
            ls_to_star: 0,
            government: Government::Corporate,
            allegiance: Allegiance::Independent,
            ed_market_id: 0,
        }
    }
}
pub struct FacilityBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FacilityBuilder<'a, 'b> {
  #[inline]
  pub fn add_facility_id(&mut self, facility_id: u32) {
    self.fbb_.push_slot::<u32>(Facility::VT_FACILITY_ID, facility_id, 0);
  }
  #[inline]
  pub fn add_system_id(&mut self, system_id: u32) {
    self.fbb_.push_slot::<u32>(Facility::VT_SYSTEM_ID, system_id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Facility::VT_NAME, name);
  }
  #[inline]
  pub fn add_timestamp_utc(&mut self, timestamp_utc: u64) {
    self.fbb_.push_slot::<u64>(Facility::VT_TIMESTAMP_UTC, timestamp_utc, 0);
  }
  #[inline]
  pub fn add_facility_type(&mut self, facility_type: FacilityType) {
    self.fbb_.push_slot::<FacilityType>(Facility::VT_FACILITY_TYPE, facility_type, FacilityType::None);
  }
  #[inline]
  pub fn add_has_market(&mut self, has_market: bool) {
    self.fbb_.push_slot::<bool>(Facility::VT_HAS_MARKET, has_market, true);
  }
  #[inline]
  pub fn add_has_black_market(&mut self, has_black_market: bool) {
    self.fbb_.push_slot::<bool>(Facility::VT_HAS_BLACK_MARKET, has_black_market, false);
  }
  #[inline]
  pub fn add_has_refuel(&mut self, has_refuel: bool) {
    self.fbb_.push_slot::<bool>(Facility::VT_HAS_REFUEL, has_refuel, true);
  }
  #[inline]
  pub fn add_has_repair(&mut self, has_repair: bool) {
    self.fbb_.push_slot::<bool>(Facility::VT_HAS_REPAIR, has_repair, true);
  }
  #[inline]
  pub fn add_has_rearm(&mut self, has_rearm: bool) {
    self.fbb_.push_slot::<bool>(Facility::VT_HAS_REARM, has_rearm, true);
  }
  #[inline]
  pub fn add_has_outfitting(&mut self, has_outfitting: bool) {
    self.fbb_.push_slot::<bool>(Facility::VT_HAS_OUTFITTING, has_outfitting, true);
  }
  #[inline]
  pub fn add_has_shipyard(&mut self, has_shipyard: bool) {
    self.fbb_.push_slot::<bool>(Facility::VT_HAS_SHIPYARD, has_shipyard, false);
  }
  #[inline]
  pub fn add_has_docking(&mut self, has_docking: bool) {
    self.fbb_.push_slot::<bool>(Facility::VT_HAS_DOCKING, has_docking, true);
  }
  #[inline]
  pub fn add_has_commodities(&mut self, has_commodities: bool) {
    self.fbb_.push_slot::<bool>(Facility::VT_HAS_COMMODITIES, has_commodities, true);
  }
  #[inline]
  pub fn add_is_planetary(&mut self, is_planetary: bool) {
    self.fbb_.push_slot::<bool>(Facility::VT_IS_PLANETARY, is_planetary, false);
  }
  #[inline]
  pub fn add_ls_to_star(&mut self, ls_to_star: u32) {
    self.fbb_.push_slot::<u32>(Facility::VT_LS_TO_STAR, ls_to_star, 0);
  }
  #[inline]
  pub fn add_government(&mut self, government: Government) {
    self.fbb_.push_slot::<Government>(Facility::VT_GOVERNMENT, government, Government::Corporate);
  }
  #[inline]
  pub fn add_allegiance(&mut self, allegiance: Allegiance) {
    self.fbb_.push_slot::<Allegiance>(Facility::VT_ALLEGIANCE, allegiance, Allegiance::Independent);
  }
  #[inline]
  pub fn add_ed_market_id(&mut self, ed_market_id: u64) {
    self.fbb_.push_slot::<u64>(Facility::VT_ED_MARKET_ID, ed_market_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FacilityBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FacilityBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Facility<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SystemOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

/// System corresponds to an individual Elite-Dangerous star system, akin to a map.
pub struct System<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for System<'a> {
    type Inner = System<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> System<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        System {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SystemArgs<'args>) -> flatbuffers::WIPOffset<System<'bldr>> {
      let mut builder = SystemBuilder::new(_fbb);
      builder.add_ed_address(args.ed_address);
      builder.add_timestamp_utc(args.timestamp_utc);
      if let Some(x) = args.facilities { builder.add_facilities(x); }
      if let Some(x) = args.power { builder.add_power(x); }
      if let Some(x) = args.position { builder.add_position(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_system_id(args.system_id);
      builder.add_allegiance_id(args.allegiance_id);
      builder.add_government_id(args.government_id);
      builder.add_security(args.security);
      builder.add_needs_permit(args.needs_permit);
      builder.add_populated(args.populated);
      builder.finish()
    }

    pub const VT_SYSTEM_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_POSITION: flatbuffers::VOffsetT = 8;
    pub const VT_TIMESTAMP_UTC: flatbuffers::VOffsetT = 10;
    pub const VT_POWER: flatbuffers::VOffsetT = 12;
    pub const VT_POPULATED: flatbuffers::VOffsetT = 14;
    pub const VT_NEEDS_PERMIT: flatbuffers::VOffsetT = 16;
    pub const VT_SECURITY: flatbuffers::VOffsetT = 18;
    pub const VT_GOVERNMENT_ID: flatbuffers::VOffsetT = 20;
    pub const VT_ALLEGIANCE_ID: flatbuffers::VOffsetT = 22;
    pub const VT_ED_ADDRESS: flatbuffers::VOffsetT = 24;
    pub const VT_FACILITIES: flatbuffers::VOffsetT = 26;

  /// System ID is it's upper-cased name hashed via fnv1a.
  #[inline]
  pub fn system_id(&self) -> u32 {
    self._tab.get::<u32>(System::VT_SYSTEM_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &System) ->  bool {
    self.system_id() < o.system_id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u32) ->  ::std::cmp::Ordering {
    let key = self.system_id();
    key.cmp(&val)
  }
  /// Unique name of the system.
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(System::VT_NAME, None)
  }
  /// Position in the galaxy.
  #[inline]
  pub fn position(&self) -> Option<&'a Coordinate> {
    self._tab.get::<Coordinate>(System::VT_POSITION, None)
  }
  /// Timestamp of the last update to this entry UTC.
  #[inline]
  pub fn timestamp_utc(&self) -> u64 {
    self._tab.get::<u64>(System::VT_TIMESTAMP_UTC, Some(0)).unwrap()
  }
  #[inline]
  pub fn power(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(System::VT_POWER, None)
  }
  /// Whether anyone lives here.
  #[inline]
  pub fn populated(&self) -> bool {
    self._tab.get::<bool>(System::VT_POPULATED, Some(true)).unwrap()
  }
  /// Whether a permit is required to enter the systme.
  #[inline]
  pub fn needs_permit(&self) -> bool {
    self._tab.get::<bool>(System::VT_NEEDS_PERMIT, Some(false)).unwrap()
  }
  /// Law-Enforcement level of the system.
  #[inline]
  pub fn security(&self) -> SecurityLevel {
    self._tab.get::<SecurityLevel>(System::VT_SECURITY, Some(SecurityLevel::Medium)).unwrap()
  }
  /// What is the government for the system.
  #[inline]
  pub fn government_id(&self) -> Government {
    self._tab.get::<Government>(System::VT_GOVERNMENT_ID, Some(Government::Corporate)).unwrap()
  }
  /// Which faction is the system allied to.
  #[inline]
  pub fn allegiance_id(&self) -> Allegiance {
    self._tab.get::<Allegiance>(System::VT_ALLEGIANCE_ID, Some(Allegiance::Independent)).unwrap()
  }
  /// Guess: Elite Dangerous Internal ID
  #[inline]
  pub fn ed_address(&self) -> u64 {
    self._tab.get::<u64>(System::VT_ED_ADDRESS, Some(0)).unwrap()
  }
  /// Facilities in this system.
  #[inline]
  pub fn facilities(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Facility<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Facility<'a>>>>>(System::VT_FACILITIES, None)
  }
}

pub struct SystemArgs<'a> {
    pub system_id: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub position: Option<&'a  Coordinate>,
    pub timestamp_utc: u64,
    pub power: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub populated: bool,
    pub needs_permit: bool,
    pub security: SecurityLevel,
    pub government_id: Government,
    pub allegiance_id: Allegiance,
    pub ed_address: u64,
    pub facilities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Facility<'a >>>>>,
}
impl<'a> Default for SystemArgs<'a> {
    #[inline]
    fn default() -> Self {
        SystemArgs {
            system_id: 0,
            name: None,
            position: None,
            timestamp_utc: 0,
            power: None,
            populated: true,
            needs_permit: false,
            security: SecurityLevel::Medium,
            government_id: Government::Corporate,
            allegiance_id: Allegiance::Independent,
            ed_address: 0,
            facilities: None,
        }
    }
}
pub struct SystemBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SystemBuilder<'a, 'b> {
  #[inline]
  pub fn add_system_id(&mut self, system_id: u32) {
    self.fbb_.push_slot::<u32>(System::VT_SYSTEM_ID, system_id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(System::VT_NAME, name);
  }
  #[inline]
  pub fn add_position(&mut self, position: &'b  Coordinate) {
    self.fbb_.push_slot_always::<&Coordinate>(System::VT_POSITION, position);
  }
  #[inline]
  pub fn add_timestamp_utc(&mut self, timestamp_utc: u64) {
    self.fbb_.push_slot::<u64>(System::VT_TIMESTAMP_UTC, timestamp_utc, 0);
  }
  #[inline]
  pub fn add_power(&mut self, power: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(System::VT_POWER, power);
  }
  #[inline]
  pub fn add_populated(&mut self, populated: bool) {
    self.fbb_.push_slot::<bool>(System::VT_POPULATED, populated, true);
  }
  #[inline]
  pub fn add_needs_permit(&mut self, needs_permit: bool) {
    self.fbb_.push_slot::<bool>(System::VT_NEEDS_PERMIT, needs_permit, false);
  }
  #[inline]
  pub fn add_security(&mut self, security: SecurityLevel) {
    self.fbb_.push_slot::<SecurityLevel>(System::VT_SECURITY, security, SecurityLevel::Medium);
  }
  #[inline]
  pub fn add_government_id(&mut self, government_id: Government) {
    self.fbb_.push_slot::<Government>(System::VT_GOVERNMENT_ID, government_id, Government::Corporate);
  }
  #[inline]
  pub fn add_allegiance_id(&mut self, allegiance_id: Allegiance) {
    self.fbb_.push_slot::<Allegiance>(System::VT_ALLEGIANCE_ID, allegiance_id, Allegiance::Independent);
  }
  #[inline]
  pub fn add_ed_address(&mut self, ed_address: u64) {
    self.fbb_.push_slot::<u64>(System::VT_ED_ADDRESS, ed_address, 0);
  }
  #[inline]
  pub fn add_facilities(&mut self, facilities: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Facility<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(System::VT_FACILITIES, facilities);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SystemBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SystemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<System<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GalaxyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

/// Encapsulation of all the data.
pub struct Galaxy<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Galaxy<'a> {
    type Inner = Galaxy<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Galaxy<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Galaxy {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GalaxyArgs<'args>) -> flatbuffers::WIPOffset<Galaxy<'bldr>> {
      let mut builder = GalaxyBuilder::new(_fbb);
      builder.add_timestamp_utc(args.timestamp_utc);
      if let Some(x) = args.yaml_data { builder.add_yaml_data(x); }
      if let Some(x) = args.json_data { builder.add_json_data(x); }
      if let Some(x) = args.ini_data { builder.add_ini_data(x); }
      if let Some(x) = args.user_data { builder.add_user_data(x); }
      if let Some(x) = args.systems { builder.add_systems(x); }
      if let Some(x) = args.commodities { builder.add_commodities(x); }
      if let Some(x) = args.attribution { builder.add_attribution(x); }
      if let Some(x) = args.description { builder.add_description(x); }
      if let Some(x) = args.schema_version { builder.add_schema_version(x); }
      builder.finish()
    }

    pub const VT_SCHEMA_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
    pub const VT_ATTRIBUTION: flatbuffers::VOffsetT = 8;
    pub const VT_TIMESTAMP_UTC: flatbuffers::VOffsetT = 10;
    pub const VT_COMMODITIES: flatbuffers::VOffsetT = 12;
    pub const VT_SYSTEMS: flatbuffers::VOffsetT = 14;
    pub const VT_USER_DATA: flatbuffers::VOffsetT = 16;
    pub const VT_INI_DATA: flatbuffers::VOffsetT = 18;
    pub const VT_JSON_DATA: flatbuffers::VOffsetT = 20;
    pub const VT_YAML_DATA: flatbuffers::VOffsetT = 22;

  /// Semantically-versioned schema id.
  #[inline]
  pub fn schema_version(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Galaxy::VT_SCHEMA_VERSION, None)
  }
  /// Human-friendly description of what is enclosed, e.g "import from source X" or
  /// "complete local database". Entirely descriptive.
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Galaxy::VT_DESCRIPTION, None)
  }
  /// Human-friendly attributition, if relevant.
  #[inline]
  pub fn attribution(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Galaxy::VT_ATTRIBUTION, None)
  }
  /// UTC Unix time of generation.
  #[inline]
  pub fn timestamp_utc(&self) -> u64 {
    self._tab.get::<u64>(Galaxy::VT_TIMESTAMP_UTC, Some(0)).unwrap()
  }
  /// Items recognized by this data.
  #[inline]
  pub fn commodities(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Commodity<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Commodity<'a>>>>>(Galaxy::VT_COMMODITIES, None)
  }
  /// Systems recognized by this data (presence of facilities optional).
  #[inline]
  pub fn systems(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<System<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<System<'a>>>>>(Galaxy::VT_SYSTEMS, None)
  }
  /// Fields reserved for any user-specific notes.
  #[inline]
  pub fn user_data(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Galaxy::VT_USER_DATA, None)
  }
  /// 3rd-party application values that prefer .ini format.
  #[inline]
  pub fn ini_data(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Galaxy::VT_INI_DATA, None)
  }
  /// 3rd-party application values that prefer .json format.
  #[inline]
  pub fn json_data(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Galaxy::VT_JSON_DATA, None)
  }
  /// 3rd-party application values that prefer .yaml because they hate life.
  #[inline]
  pub fn yaml_data(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Galaxy::VT_YAML_DATA, None)
  }
}

pub struct GalaxyArgs<'a> {
    pub schema_version: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub attribution: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub timestamp_utc: u64,
    pub commodities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Commodity<'a >>>>>,
    pub systems: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<System<'a >>>>>,
    pub user_data: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub ini_data: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub json_data: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub yaml_data: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for GalaxyArgs<'a> {
    #[inline]
    fn default() -> Self {
        GalaxyArgs {
            schema_version: None,
            description: None,
            attribution: None,
            timestamp_utc: 0,
            commodities: None,
            systems: None,
            user_data: None,
            ini_data: None,
            json_data: None,
            yaml_data: None,
        }
    }
}
pub struct GalaxyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GalaxyBuilder<'a, 'b> {
  #[inline]
  pub fn add_schema_version(&mut self, schema_version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Galaxy::VT_SCHEMA_VERSION, schema_version);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Galaxy::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_attribution(&mut self, attribution: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Galaxy::VT_ATTRIBUTION, attribution);
  }
  #[inline]
  pub fn add_timestamp_utc(&mut self, timestamp_utc: u64) {
    self.fbb_.push_slot::<u64>(Galaxy::VT_TIMESTAMP_UTC, timestamp_utc, 0);
  }
  #[inline]
  pub fn add_commodities(&mut self, commodities: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Commodity<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Galaxy::VT_COMMODITIES, commodities);
  }
  #[inline]
  pub fn add_systems(&mut self, systems: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<System<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Galaxy::VT_SYSTEMS, systems);
  }
  #[inline]
  pub fn add_user_data(&mut self, user_data: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Galaxy::VT_USER_DATA, user_data);
  }
  #[inline]
  pub fn add_ini_data(&mut self, ini_data: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Galaxy::VT_INI_DATA, ini_data);
  }
  #[inline]
  pub fn add_json_data(&mut self, json_data: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Galaxy::VT_JSON_DATA, json_data);
  }
  #[inline]
  pub fn add_yaml_data(&mut self, yaml_data: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Galaxy::VT_YAML_DATA, yaml_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GalaxyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GalaxyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Galaxy<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_galaxy<'a>(buf: &'a [u8]) -> Galaxy<'a> {
  flatbuffers::get_root::<Galaxy<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_galaxy<'a>(buf: &'a [u8]) -> Galaxy<'a> {
  flatbuffers::get_size_prefixed_root::<Galaxy<'a>>(buf)
}

pub const GALAXY_IDENTIFIER: &'static str = "gomd";

#[inline]
pub fn galaxy_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, GALAXY_IDENTIFIER, false);
}

#[inline]
pub fn galaxy_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, GALAXY_IDENTIFIER, true);
}

#[inline]
pub fn finish_galaxy_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Galaxy<'a>>) {
  fbb.finish(root, Some(GALAXY_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_galaxy_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Galaxy<'a>>) {
  fbb.finish_size_prefixed(root, Some(GALAXY_IDENTIFIER));
}
}  // pub mod gomschema

