// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gomschema.proto

#ifndef PROTOBUF_INCLUDED_gomschema_2eproto
#define PROTOBUF_INCLUDED_gomschema_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_gomschema_2eproto 

namespace protobuf_gomschema_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_gomschema_2eproto
namespace gomschema {
class Commodity;
class CommodityDefaultTypeInternal;
extern CommodityDefaultTypeInternal _Commodity_default_instance_;
class Commodity_UserdataEntry_DoNotUse;
class Commodity_UserdataEntry_DoNotUseDefaultTypeInternal;
extern Commodity_UserdataEntry_DoNotUseDefaultTypeInternal _Commodity_UserdataEntry_DoNotUse_default_instance_;
class Coordinate;
class CoordinateDefaultTypeInternal;
extern CoordinateDefaultTypeInternal _Coordinate_default_instance_;
class Facility;
class FacilityDefaultTypeInternal;
extern FacilityDefaultTypeInternal _Facility_default_instance_;
class FacilityListing;
class FacilityListingDefaultTypeInternal;
extern FacilityListingDefaultTypeInternal _FacilityListing_default_instance_;
class Facility_UserdataEntry_DoNotUse;
class Facility_UserdataEntry_DoNotUseDefaultTypeInternal;
extern Facility_UserdataEntry_DoNotUseDefaultTypeInternal _Facility_UserdataEntry_DoNotUse_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Header_UserdataEntry_DoNotUse;
class Header_UserdataEntry_DoNotUseDefaultTypeInternal;
extern Header_UserdataEntry_DoNotUseDefaultTypeInternal _Header_UserdataEntry_DoNotUse_default_instance_;
class Services;
class ServicesDefaultTypeInternal;
extern ServicesDefaultTypeInternal _Services_default_instance_;
class System;
class SystemDefaultTypeInternal;
extern SystemDefaultTypeInternal _System_default_instance_;
class System_UserdataEntry_DoNotUse;
class System_UserdataEntry_DoNotUseDefaultTypeInternal;
extern System_UserdataEntry_DoNotUseDefaultTypeInternal _System_UserdataEntry_DoNotUse_default_instance_;
class Trade;
class TradeDefaultTypeInternal;
extern TradeDefaultTypeInternal _Trade_default_instance_;
}  // namespace gomschema
namespace google {
namespace protobuf {
template<> ::gomschema::Commodity* Arena::CreateMaybeMessage<::gomschema::Commodity>(Arena*);
template<> ::gomschema::Commodity_UserdataEntry_DoNotUse* Arena::CreateMaybeMessage<::gomschema::Commodity_UserdataEntry_DoNotUse>(Arena*);
template<> ::gomschema::Coordinate* Arena::CreateMaybeMessage<::gomschema::Coordinate>(Arena*);
template<> ::gomschema::Facility* Arena::CreateMaybeMessage<::gomschema::Facility>(Arena*);
template<> ::gomschema::FacilityListing* Arena::CreateMaybeMessage<::gomschema::FacilityListing>(Arena*);
template<> ::gomschema::Facility_UserdataEntry_DoNotUse* Arena::CreateMaybeMessage<::gomschema::Facility_UserdataEntry_DoNotUse>(Arena*);
template<> ::gomschema::Header* Arena::CreateMaybeMessage<::gomschema::Header>(Arena*);
template<> ::gomschema::Header_UserdataEntry_DoNotUse* Arena::CreateMaybeMessage<::gomschema::Header_UserdataEntry_DoNotUse>(Arena*);
template<> ::gomschema::Services* Arena::CreateMaybeMessage<::gomschema::Services>(Arena*);
template<> ::gomschema::System* Arena::CreateMaybeMessage<::gomschema::System>(Arena*);
template<> ::gomschema::System_UserdataEntry_DoNotUse* Arena::CreateMaybeMessage<::gomschema::System_UserdataEntry_DoNotUse>(Arena*);
template<> ::gomschema::Trade* Arena::CreateMaybeMessage<::gomschema::Trade>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace gomschema {

enum Header_Class {
  Header_Class_CCategory = 0,
  Header_Class_CSystem = 1,
  Header_Class_CFacility = 2,
  Header_Class_CListing = 3
};
bool Header_Class_IsValid(int value);
const Header_Class Header_Class_Class_MIN = Header_Class_CCategory;
const Header_Class Header_Class_Class_MAX = Header_Class_CListing;
const int Header_Class_Class_ARRAYSIZE = Header_Class_Class_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_Class_descriptor();
inline const ::std::string& Header_Class_Name(Header_Class value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_Class_descriptor(), value);
}
inline bool Header_Class_Parse(
    const ::std::string& name, Header_Class* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_Class>(
    Header_Class_descriptor(), name, value);
}
enum Commodity_CommodityCategory {
  Commodity_CommodityCategory_CatNone = 0,
  Commodity_CommodityCategory_CatChemicals = 1,
  Commodity_CommodityCategory_CatConsumerItems = 2,
  Commodity_CommodityCategory_CatLegalDrugs = 3,
  Commodity_CommodityCategory_CatFoods = 4,
  Commodity_CommodityCategory_CatIndustrialMaterials = 5,
  Commodity_CommodityCategory_CatMachinery = 6,
  Commodity_CommodityCategory_CatMedicines = 7,
  Commodity_CommodityCategory_CatMetals = 8,
  Commodity_CommodityCategory_CatMinerals = 9,
  Commodity_CommodityCategory_CatSlavery = 10,
  Commodity_CommodityCategory_CatTechnology = 11,
  Commodity_CommodityCategory_CatTextiles = 12,
  Commodity_CommodityCategory_CatWaste = 13,
  Commodity_CommodityCategory_CatWeapons = 14,
  Commodity_CommodityCategory_CatUnknown = 15,
  Commodity_CommodityCategory_CatSalvage = 16
};
bool Commodity_CommodityCategory_IsValid(int value);
const Commodity_CommodityCategory Commodity_CommodityCategory_CommodityCategory_MIN = Commodity_CommodityCategory_CatNone;
const Commodity_CommodityCategory Commodity_CommodityCategory_CommodityCategory_MAX = Commodity_CommodityCategory_CatSalvage;
const int Commodity_CommodityCategory_CommodityCategory_ARRAYSIZE = Commodity_CommodityCategory_CommodityCategory_MAX + 1;

const ::google::protobuf::EnumDescriptor* Commodity_CommodityCategory_descriptor();
inline const ::std::string& Commodity_CommodityCategory_Name(Commodity_CommodityCategory value) {
  return ::google::protobuf::internal::NameOfEnum(
    Commodity_CommodityCategory_descriptor(), value);
}
inline bool Commodity_CommodityCategory_Parse(
    const ::std::string& name, Commodity_CommodityCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Commodity_CommodityCategory>(
    Commodity_CommodityCategory_descriptor(), name, value);
}
enum GovernmentType {
  GovNone = 0,
  GovAnarchy = 1,
  GovCommunism = 2,
  GovConfederacy = 3,
  GovCooperative = 4,
  GovCorporate = 5,
  GovDemocracy = 6,
  GovDictatorship = 7,
  GovFeudal = 8,
  GovPatronage = 9,
  GovPrison = 10,
  GovPrisonColony = 11,
  GovTheocracy = 12
};
bool GovernmentType_IsValid(int value);
const GovernmentType GovernmentType_MIN = GovNone;
const GovernmentType GovernmentType_MAX = GovTheocracy;
const int GovernmentType_ARRAYSIZE = GovernmentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GovernmentType_descriptor();
inline const ::std::string& GovernmentType_Name(GovernmentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GovernmentType_descriptor(), value);
}
inline bool GovernmentType_Parse(
    const ::std::string& name, GovernmentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GovernmentType>(
    GovernmentType_descriptor(), name, value);
}
enum AllegianceType {
  AllegNone = 0,
  AllegAlliance = 1,
  AllegEmpire = 2,
  AllegFederation = 3,
  AllegIndependent = 4,
  AllegPilotsFederation = 5
};
bool AllegianceType_IsValid(int value);
const AllegianceType AllegianceType_MIN = AllegNone;
const AllegianceType AllegianceType_MAX = AllegPilotsFederation;
const int AllegianceType_ARRAYSIZE = AllegianceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AllegianceType_descriptor();
inline const ::std::string& AllegianceType_Name(AllegianceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AllegianceType_descriptor(), value);
}
inline bool AllegianceType_Parse(
    const ::std::string& name, AllegianceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AllegianceType>(
    AllegianceType_descriptor(), name, value);
}
enum SecurityLevel {
  SecurityNone = 0,
  SecurityAnarchy = 1,
  SecurityLow = 2,
  SecurityMedium = 3,
  SecurityHigh = 4
};
bool SecurityLevel_IsValid(int value);
const SecurityLevel SecurityLevel_MIN = SecurityNone;
const SecurityLevel SecurityLevel_MAX = SecurityHigh;
const int SecurityLevel_ARRAYSIZE = SecurityLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityLevel_descriptor();
inline const ::std::string& SecurityLevel_Name(SecurityLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityLevel_descriptor(), value);
}
inline bool SecurityLevel_Parse(
    const ::std::string& name, SecurityLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityLevel>(
    SecurityLevel_descriptor(), name, value);
}
enum FacilityType {
  FTNone = 0,
  FTCivilianOutpost = 1,
  FTCommercialOutpost = 2,
  FTCoriolisStarport = 3,
  FTIndustrialOutpost = 4,
  FTMilitaryOutpost = 5,
  FTMiningOutpost = 6,
  FTOcellusStarport = 7,
  FTOrbisStarport = 8,
  FTScientificOutpost = 9,
  FTPlanetaryOutpost = 10,
  FTPlanetaryPort = 11,
  FTPlanetarySettlement = 12,
  FTMegaship = 13,
  FTAsteroidBase = 14,
  FTFleetCarrier = 15
};
bool FacilityType_IsValid(int value);
const FacilityType FacilityType_MIN = FTNone;
const FacilityType FacilityType_MAX = FTFleetCarrier;
const int FacilityType_ARRAYSIZE = FacilityType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FacilityType_descriptor();
inline const ::std::string& FacilityType_Name(FacilityType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FacilityType_descriptor(), value);
}
inline bool FacilityType_Parse(
    const ::std::string& name, FacilityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FacilityType>(
    FacilityType_descriptor(), name, value);
}
enum PadSize {
  PadNone = 0,
  PadSmall = 1,
  PadMedium = 2,
  PadLarge = 3
};
bool PadSize_IsValid(int value);
const PadSize PadSize_MIN = PadNone;
const PadSize PadSize_MAX = PadLarge;
const int PadSize_ARRAYSIZE = PadSize_MAX + 1;

const ::google::protobuf::EnumDescriptor* PadSize_descriptor();
inline const ::std::string& PadSize_Name(PadSize value) {
  return ::google::protobuf::internal::NameOfEnum(
    PadSize_descriptor(), value);
}
inline bool PadSize_Parse(
    const ::std::string& name, PadSize* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PadSize>(
    PadSize_descriptor(), name, value);
}
// ===================================================================

class Header_UserdataEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Header_UserdataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Header_UserdataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  Header_UserdataEntry_DoNotUse();
  Header_UserdataEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Header_UserdataEntry_DoNotUse& other);
  static const Header_UserdataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Header_UserdataEntry_DoNotUse*>(&_Header_UserdataEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gomschema.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(NULL);
  }

  Header* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef Header_Class Class;
  static const Class CCategory =
    Header_Class_CCategory;
  static const Class CSystem =
    Header_Class_CSystem;
  static const Class CFacility =
    Header_Class_CFacility;
  static const Class CListing =
    Header_Class_CListing;
  static inline bool Class_IsValid(int value) {
    return Header_Class_IsValid(value);
  }
  static const Class Class_MIN =
    Header_Class_Class_MIN;
  static const Class Class_MAX =
    Header_Class_Class_MAX;
  static const int Class_ARRAYSIZE =
    Header_Class_Class_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Class_descriptor() {
    return Header_Class_descriptor();
  }
  static inline const ::std::string& Class_Name(Class value) {
    return Header_Class_Name(value);
  }
  static inline bool Class_Parse(const ::std::string& name,
      Class* value) {
    return Header_Class_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated uint32 sizes = 2 [packed = true];
  int sizes_size() const;
  void clear_sizes();
  static const int kSizesFieldNumber = 2;
  ::google::protobuf::uint32 sizes(int index) const;
  void set_sizes(int index, ::google::protobuf::uint32 value);
  void add_sizes(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      sizes() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_sizes();

  // map<string, bytes> userdata = 3;
  int userdata_size() const;
  void clear_userdata();
  static const int kUserdataFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      userdata() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_userdata();

  // required .gomschema.Header.Class class = 1;
  bool has_class_() const;
  void clear_class_();
  static const int kClassFieldNumber = 1;
  ::gomschema::Header_Class class_() const;
  void set_class_(::gomschema::Header_Class value);

  // @@protoc_insertion_point(class_scope:gomschema.Header)
 private:
  void set_has_class_();
  void clear_has_class_();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > sizes_;
  mutable int _sizes_cached_byte_size_;
  ::google::protobuf::internal::MapField<
      Header_UserdataEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > userdata_;
  int class__;
  friend struct ::protobuf_gomschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Commodity_UserdataEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Commodity_UserdataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Commodity_UserdataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  Commodity_UserdataEntry_DoNotUse();
  Commodity_UserdataEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Commodity_UserdataEntry_DoNotUse& other);
  static const Commodity_UserdataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Commodity_UserdataEntry_DoNotUse*>(&_Commodity_UserdataEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Commodity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gomschema.Commodity) */ {
 public:
  Commodity();
  virtual ~Commodity();

  Commodity(const Commodity& from);

  inline Commodity& operator=(const Commodity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Commodity(Commodity&& from) noexcept
    : Commodity() {
    *this = ::std::move(from);
  }

  inline Commodity& operator=(Commodity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Commodity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Commodity* internal_default_instance() {
    return reinterpret_cast<const Commodity*>(
               &_Commodity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Commodity* other);
  friend void swap(Commodity& a, Commodity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Commodity* New() const final {
    return CreateMaybeMessage<Commodity>(NULL);
  }

  Commodity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Commodity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Commodity& from);
  void MergeFrom(const Commodity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Commodity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef Commodity_CommodityCategory CommodityCategory;
  static const CommodityCategory CatNone =
    Commodity_CommodityCategory_CatNone;
  static const CommodityCategory CatChemicals =
    Commodity_CommodityCategory_CatChemicals;
  static const CommodityCategory CatConsumerItems =
    Commodity_CommodityCategory_CatConsumerItems;
  static const CommodityCategory CatLegalDrugs =
    Commodity_CommodityCategory_CatLegalDrugs;
  static const CommodityCategory CatFoods =
    Commodity_CommodityCategory_CatFoods;
  static const CommodityCategory CatIndustrialMaterials =
    Commodity_CommodityCategory_CatIndustrialMaterials;
  static const CommodityCategory CatMachinery =
    Commodity_CommodityCategory_CatMachinery;
  static const CommodityCategory CatMedicines =
    Commodity_CommodityCategory_CatMedicines;
  static const CommodityCategory CatMetals =
    Commodity_CommodityCategory_CatMetals;
  static const CommodityCategory CatMinerals =
    Commodity_CommodityCategory_CatMinerals;
  static const CommodityCategory CatSlavery =
    Commodity_CommodityCategory_CatSlavery;
  static const CommodityCategory CatTechnology =
    Commodity_CommodityCategory_CatTechnology;
  static const CommodityCategory CatTextiles =
    Commodity_CommodityCategory_CatTextiles;
  static const CommodityCategory CatWaste =
    Commodity_CommodityCategory_CatWaste;
  static const CommodityCategory CatWeapons =
    Commodity_CommodityCategory_CatWeapons;
  static const CommodityCategory CatUnknown =
    Commodity_CommodityCategory_CatUnknown;
  static const CommodityCategory CatSalvage =
    Commodity_CommodityCategory_CatSalvage;
  static inline bool CommodityCategory_IsValid(int value) {
    return Commodity_CommodityCategory_IsValid(value);
  }
  static const CommodityCategory CommodityCategory_MIN =
    Commodity_CommodityCategory_CommodityCategory_MIN;
  static const CommodityCategory CommodityCategory_MAX =
    Commodity_CommodityCategory_CommodityCategory_MAX;
  static const int CommodityCategory_ARRAYSIZE =
    Commodity_CommodityCategory_CommodityCategory_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommodityCategory_descriptor() {
    return Commodity_CommodityCategory_descriptor();
  }
  static inline const ::std::string& CommodityCategory_Name(CommodityCategory value) {
    return Commodity_CommodityCategory_Name(value);
  }
  static inline bool CommodityCategory_Parse(const ::std::string& name,
      CommodityCategory* value) {
    return Commodity_CommodityCategory_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // map<string, bytes> userdata = 8;
  int userdata_size() const;
  void clear_userdata();
  static const int kUserdataFieldNumber = 8;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      userdata() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_userdata();

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint64 commodity_id = 1;
  bool has_commodity_id() const;
  void clear_commodity_id();
  static const int kCommodityIdFieldNumber = 1;
  ::google::protobuf::uint64 commodity_id() const;
  void set_commodity_id(::google::protobuf::uint64 value);

  // optional uint64 timestamp_utc = 3 [default = 0];
  bool has_timestamp_utc() const;
  void clear_timestamp_utc();
  static const int kTimestampUtcFieldNumber = 3;
  ::google::protobuf::uint64 timestamp_utc() const;
  void set_timestamp_utc(::google::protobuf::uint64 value);

  // required .gomschema.Commodity.CommodityCategory category_id = 4;
  bool has_category_id() const;
  void clear_category_id();
  static const int kCategoryIdFieldNumber = 4;
  ::gomschema::Commodity_CommodityCategory category_id() const;
  void set_category_id(::gomschema::Commodity_CommodityCategory value);

  // optional bool is_rare = 5 [default = false];
  bool has_is_rare() const;
  void clear_is_rare();
  static const int kIsRareFieldNumber = 5;
  bool is_rare() const;
  void set_is_rare(bool value);

  // optional bool is_non_marketable = 6 [default = false];
  bool has_is_non_marketable() const;
  void clear_is_non_marketable();
  static const int kIsNonMarketableFieldNumber = 6;
  bool is_non_marketable() const;
  void set_is_non_marketable(bool value);

  // optional uint32 average_cr = 7;
  bool has_average_cr() const;
  void clear_average_cr();
  static const int kAverageCrFieldNumber = 7;
  ::google::protobuf::uint32 average_cr() const;
  void set_average_cr(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:gomschema.Commodity)
 private:
  void set_has_commodity_id();
  void clear_has_commodity_id();
  void set_has_name();
  void clear_has_name();
  void set_has_timestamp_utc();
  void clear_has_timestamp_utc();
  void set_has_category_id();
  void clear_has_category_id();
  void set_has_is_rare();
  void clear_has_is_rare();
  void set_has_is_non_marketable();
  void clear_has_is_non_marketable();
  void set_has_average_cr();
  void clear_has_average_cr();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::MapField<
      Commodity_UserdataEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > userdata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 commodity_id_;
  ::google::protobuf::uint64 timestamp_utc_;
  int category_id_;
  bool is_rare_;
  bool is_non_marketable_;
  ::google::protobuf::uint32 average_cr_;
  friend struct ::protobuf_gomschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Coordinate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gomschema.Coordinate) */ {
 public:
  Coordinate();
  virtual ~Coordinate();

  Coordinate(const Coordinate& from);

  inline Coordinate& operator=(const Coordinate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Coordinate(Coordinate&& from) noexcept
    : Coordinate() {
    *this = ::std::move(from);
  }

  inline Coordinate& operator=(Coordinate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Coordinate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Coordinate* internal_default_instance() {
    return reinterpret_cast<const Coordinate*>(
               &_Coordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Coordinate* other);
  friend void swap(Coordinate& a, Coordinate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Coordinate* New() const final {
    return CreateMaybeMessage<Coordinate>(NULL);
  }

  Coordinate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Coordinate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Coordinate& from);
  void MergeFrom(const Coordinate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Coordinate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:gomschema.Coordinate)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::protobuf_gomschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class System_UserdataEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<System_UserdataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<System_UserdataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  System_UserdataEntry_DoNotUse();
  System_UserdataEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const System_UserdataEntry_DoNotUse& other);
  static const System_UserdataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const System_UserdataEntry_DoNotUse*>(&_System_UserdataEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class System : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gomschema.System) */ {
 public:
  System();
  virtual ~System();

  System(const System& from);

  inline System& operator=(const System& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  System(System&& from) noexcept
    : System() {
    *this = ::std::move(from);
  }

  inline System& operator=(System&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const System& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const System* internal_default_instance() {
    return reinterpret_cast<const System*>(
               &_System_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(System* other);
  friend void swap(System& a, System& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline System* New() const final {
    return CreateMaybeMessage<System>(NULL);
  }

  System* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<System>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const System& from);
  void MergeFrom(const System& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(System* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> userdata = 11;
  int userdata_size() const;
  void clear_userdata();
  static const int kUserdataFieldNumber = 11;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      userdata() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_userdata();

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .gomschema.Coordinate position = 4;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 4;
  private:
  const ::gomschema::Coordinate& _internal_position() const;
  public:
  const ::gomschema::Coordinate& position() const;
  ::gomschema::Coordinate* release_position();
  ::gomschema::Coordinate* mutable_position();
  void set_allocated_position(::gomschema::Coordinate* position);

  // optional uint64 timestamp_utc = 3 [default = 0];
  bool has_timestamp_utc() const;
  void clear_timestamp_utc();
  static const int kTimestampUtcFieldNumber = 3;
  ::google::protobuf::uint64 timestamp_utc() const;
  void set_timestamp_utc(::google::protobuf::uint64 value);

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional bool needs_permit = 6 [default = false];
  bool has_needs_permit() const;
  void clear_needs_permit();
  static const int kNeedsPermitFieldNumber = 6;
  bool needs_permit() const;
  void set_needs_permit(bool value);

  // optional uint64 ed_address = 10 [default = 0];
  bool has_ed_address() const;
  void clear_ed_address();
  static const int kEdAddressFieldNumber = 10;
  ::google::protobuf::uint64 ed_address() const;
  void set_ed_address(::google::protobuf::uint64 value);

  // optional bool populated = 5 [default = true];
  bool has_populated() const;
  void clear_populated();
  static const int kPopulatedFieldNumber = 5;
  bool populated() const;
  void set_populated(bool value);

  // optional .gomschema.SecurityLevel security_level = 7 [default = SecurityMedium];
  bool has_security_level() const;
  void clear_security_level();
  static const int kSecurityLevelFieldNumber = 7;
  ::gomschema::SecurityLevel security_level() const;
  void set_security_level(::gomschema::SecurityLevel value);

  // optional .gomschema.GovernmentType government = 8 [default = GovCorporate];
  bool has_government() const;
  void clear_government();
  static const int kGovernmentFieldNumber = 8;
  ::gomschema::GovernmentType government() const;
  void set_government(::gomschema::GovernmentType value);

  // optional .gomschema.AllegianceType allegiance = 9 [default = AllegIndependent];
  bool has_allegiance() const;
  void clear_allegiance();
  static const int kAllegianceFieldNumber = 9;
  ::gomschema::AllegianceType allegiance() const;
  void set_allegiance(::gomschema::AllegianceType value);

  // @@protoc_insertion_point(class_scope:gomschema.System)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_timestamp_utc();
  void clear_has_timestamp_utc();
  void set_has_position();
  void clear_has_position();
  void set_has_populated();
  void clear_has_populated();
  void set_has_needs_permit();
  void clear_has_needs_permit();
  void set_has_security_level();
  void clear_has_security_level();
  void set_has_government();
  void clear_has_government();
  void set_has_allegiance();
  void clear_has_allegiance();
  void set_has_ed_address();
  void clear_has_ed_address();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::MapField<
      System_UserdataEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > userdata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::gomschema::Coordinate* position_;
  ::google::protobuf::uint64 timestamp_utc_;
  ::google::protobuf::uint32 id_;
  bool needs_permit_;
  ::google::protobuf::uint64 ed_address_;
  bool populated_;
  int security_level_;
  int government_;
  int allegiance_;
  friend struct ::protobuf_gomschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Services : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gomschema.Services) */ {
 public:
  Services();
  virtual ~Services();

  Services(const Services& from);

  inline Services& operator=(const Services& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Services(Services&& from) noexcept
    : Services() {
    *this = ::std::move(from);
  }

  inline Services& operator=(Services&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Services& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Services* internal_default_instance() {
    return reinterpret_cast<const Services*>(
               &_Services_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Services* other);
  friend void swap(Services& a, Services& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Services* New() const final {
    return CreateMaybeMessage<Services>(NULL);
  }

  Services* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Services>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Services& from);
  void MergeFrom(const Services& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Services* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool has_black_market = 2;
  bool has_has_black_market() const;
  void clear_has_black_market();
  static const int kHasBlackMarketFieldNumber = 2;
  bool has_black_market() const;
  void set_has_black_market(bool value);

  // required bool has_outfitting = 6;
  bool has_has_outfitting() const;
  void clear_has_outfitting();
  static const int kHasOutfittingFieldNumber = 6;
  bool has_outfitting() const;
  void set_has_outfitting(bool value);

  // required bool has_shipyard = 7;
  bool has_has_shipyard() const;
  void clear_has_shipyard();
  static const int kHasShipyardFieldNumber = 7;
  bool has_shipyard() const;
  void set_has_shipyard(bool value);

  // optional bool has_market = 1 [default = true];
  bool has_has_market() const;
  void clear_has_market();
  static const int kHasMarketFieldNumber = 1;
  bool has_market() const;
  void set_has_market(bool value);

  // optional bool has_refuel = 3 [default = true];
  bool has_has_refuel() const;
  void clear_has_refuel();
  static const int kHasRefuelFieldNumber = 3;
  bool has_refuel() const;
  void set_has_refuel(bool value);

  // optional bool has_repair = 4 [default = true];
  bool has_has_repair() const;
  void clear_has_repair();
  static const int kHasRepairFieldNumber = 4;
  bool has_repair() const;
  void set_has_repair(bool value);

  // optional bool has_rearm = 5 [default = true];
  bool has_has_rearm() const;
  void clear_has_rearm();
  static const int kHasRearmFieldNumber = 5;
  bool has_rearm() const;
  void set_has_rearm(bool value);

  // optional bool has_docking = 8 [default = true];
  bool has_has_docking() const;
  void clear_has_docking();
  static const int kHasDockingFieldNumber = 8;
  bool has_docking() const;
  void set_has_docking(bool value);

  // optional bool has_commodities = 9 [default = true];
  bool has_has_commodities() const;
  void clear_has_commodities();
  static const int kHasCommoditiesFieldNumber = 9;
  bool has_commodities() const;
  void set_has_commodities(bool value);

  // required bool is_planetary = 10 [default = true];
  bool has_is_planetary() const;
  void clear_is_planetary();
  static const int kIsPlanetaryFieldNumber = 10;
  bool is_planetary() const;
  void set_is_planetary(bool value);

  // @@protoc_insertion_point(class_scope:gomschema.Services)
 private:
  void set_has_has_market();
  void clear_has_has_market();
  void set_has_has_black_market();
  void clear_has_has_black_market();
  void set_has_has_refuel();
  void clear_has_has_refuel();
  void set_has_has_repair();
  void clear_has_has_repair();
  void set_has_has_rearm();
  void clear_has_has_rearm();
  void set_has_has_outfitting();
  void clear_has_has_outfitting();
  void set_has_has_shipyard();
  void clear_has_has_shipyard();
  void set_has_has_docking();
  void clear_has_has_docking();
  void set_has_has_commodities();
  void clear_has_has_commodities();
  void set_has_is_planetary();
  void clear_has_is_planetary();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool has_black_market_;
  bool has_outfitting_;
  bool has_shipyard_;
  bool has_market_;
  bool has_refuel_;
  bool has_repair_;
  bool has_rearm_;
  bool has_docking_;
  bool has_commodities_;
  bool is_planetary_;
  friend struct ::protobuf_gomschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Facility_UserdataEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Facility_UserdataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Facility_UserdataEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  Facility_UserdataEntry_DoNotUse();
  Facility_UserdataEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Facility_UserdataEntry_DoNotUse& other);
  static const Facility_UserdataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Facility_UserdataEntry_DoNotUse*>(&_Facility_UserdataEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Facility : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gomschema.Facility) */ {
 public:
  Facility();
  virtual ~Facility();

  Facility(const Facility& from);

  inline Facility& operator=(const Facility& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Facility(Facility&& from) noexcept
    : Facility() {
    *this = ::std::move(from);
  }

  inline Facility& operator=(Facility&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Facility& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Facility* internal_default_instance() {
    return reinterpret_cast<const Facility*>(
               &_Facility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Facility* other);
  friend void swap(Facility& a, Facility& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Facility* New() const final {
    return CreateMaybeMessage<Facility>(NULL);
  }

  Facility* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Facility>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Facility& from);
  void MergeFrom(const Facility& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Facility* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> userdata = 12;
  int userdata_size() const;
  void clear_userdata();
  static const int kUserdataFieldNumber = 12;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      userdata() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_userdata();

  // required string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .gomschema.Services services = 6;
  bool has_services() const;
  void clear_services();
  static const int kServicesFieldNumber = 6;
  private:
  const ::gomschema::Services& _internal_services() const;
  public:
  const ::gomschema::Services& services() const;
  ::gomschema::Services* release_services();
  ::gomschema::Services* mutable_services();
  void set_allocated_services(::gomschema::Services* services);

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // required uint32 system_id = 2;
  bool has_system_id() const;
  void clear_system_id();
  static const int kSystemIdFieldNumber = 2;
  ::google::protobuf::uint32 system_id() const;
  void set_system_id(::google::protobuf::uint32 value);

  // optional uint64 timestamp_utc = 4 [default = 0];
  bool has_timestamp_utc() const;
  void clear_timestamp_utc();
  static const int kTimestampUtcFieldNumber = 4;
  ::google::protobuf::uint64 timestamp_utc() const;
  void set_timestamp_utc(::google::protobuf::uint64 value);

  // optional uint64 ed_market_id = 11 [default = 0];
  bool has_ed_market_id() const;
  void clear_ed_market_id();
  static const int kEdMarketIdFieldNumber = 11;
  ::google::protobuf::uint64 ed_market_id() const;
  void set_ed_market_id(::google::protobuf::uint64 value);

  // optional uint32 ls_from_star = 8;
  bool has_ls_from_star() const;
  void clear_ls_from_star();
  static const int kLsFromStarFieldNumber = 8;
  ::google::protobuf::uint32 ls_from_star() const;
  void set_ls_from_star(::google::protobuf::uint32 value);

  // optional .gomschema.FacilityType facility_type = 5 [default = FTPlanetaryOutpost];
  bool has_facility_type() const;
  void clear_facility_type();
  static const int kFacilityTypeFieldNumber = 5;
  ::gomschema::FacilityType facility_type() const;
  void set_facility_type(::gomschema::FacilityType value);

  // optional .gomschema.PadSize pad_size = 7 [default = PadMedium];
  bool has_pad_size() const;
  void clear_pad_size();
  static const int kPadSizeFieldNumber = 7;
  ::gomschema::PadSize pad_size() const;
  void set_pad_size(::gomschema::PadSize value);

  // optional .gomschema.GovernmentType government = 9 [default = GovCorporate];
  bool has_government() const;
  void clear_government();
  static const int kGovernmentFieldNumber = 9;
  ::gomschema::GovernmentType government() const;
  void set_government(::gomschema::GovernmentType value);

  // optional .gomschema.AllegianceType allegiance = 10 [default = AllegIndependent];
  bool has_allegiance() const;
  void clear_allegiance();
  static const int kAllegianceFieldNumber = 10;
  ::gomschema::AllegianceType allegiance() const;
  void set_allegiance(::gomschema::AllegianceType value);

  // @@protoc_insertion_point(class_scope:gomschema.Facility)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_system_id();
  void clear_has_system_id();
  void set_has_name();
  void clear_has_name();
  void set_has_timestamp_utc();
  void clear_has_timestamp_utc();
  void set_has_facility_type();
  void clear_has_facility_type();
  void set_has_services();
  void clear_has_services();
  void set_has_pad_size();
  void clear_has_pad_size();
  void set_has_ls_from_star();
  void clear_has_ls_from_star();
  void set_has_government();
  void clear_has_government();
  void set_has_allegiance();
  void clear_has_allegiance();
  void set_has_ed_market_id();
  void clear_has_ed_market_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::MapField<
      Facility_UserdataEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > userdata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::gomschema::Services* services_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 system_id_;
  ::google::protobuf::uint64 timestamp_utc_;
  ::google::protobuf::uint64 ed_market_id_;
  ::google::protobuf::uint32 ls_from_star_;
  int facility_type_;
  int pad_size_;
  int government_;
  int allegiance_;
  friend struct ::protobuf_gomschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Trade : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gomschema.Trade) */ {
 public:
  Trade();
  virtual ~Trade();

  Trade(const Trade& from);

  inline Trade& operator=(const Trade& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trade(Trade&& from) noexcept
    : Trade() {
    *this = ::std::move(from);
  }

  inline Trade& operator=(Trade&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trade& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trade* internal_default_instance() {
    return reinterpret_cast<const Trade*>(
               &_Trade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Trade* other);
  friend void swap(Trade& a, Trade& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trade* New() const final {
    return CreateMaybeMessage<Trade>(NULL);
  }

  Trade* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Trade>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Trade& from);
  void MergeFrom(const Trade& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trade* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 commodity_id = 1;
  bool has_commodity_id() const;
  void clear_commodity_id();
  static const int kCommodityIdFieldNumber = 1;
  ::google::protobuf::uint32 commodity_id() const;
  void set_commodity_id(::google::protobuf::uint32 value);

  // required uint32 units = 2;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 2;
  ::google::protobuf::uint32 units() const;
  void set_units(::google::protobuf::uint32 value);

  // optional uint64 timestamp_utc = 4 [default = 0];
  bool has_timestamp_utc() const;
  void clear_timestamp_utc();
  static const int kTimestampUtcFieldNumber = 4;
  ::google::protobuf::uint64 timestamp_utc() const;
  void set_timestamp_utc(::google::protobuf::uint64 value);

  // required int32 credits = 3;
  bool has_credits() const;
  void clear_credits();
  static const int kCreditsFieldNumber = 3;
  ::google::protobuf::int32 credits() const;
  void set_credits(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gomschema.Trade)
 private:
  void set_has_commodity_id();
  void clear_has_commodity_id();
  void set_has_units();
  void clear_has_units();
  void set_has_credits();
  void clear_has_credits();
  void set_has_timestamp_utc();
  void clear_has_timestamp_utc();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 commodity_id_;
  ::google::protobuf::uint32 units_;
  ::google::protobuf::uint64 timestamp_utc_;
  ::google::protobuf::int32 credits_;
  friend struct ::protobuf_gomschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FacilityListing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gomschema.FacilityListing) */ {
 public:
  FacilityListing();
  virtual ~FacilityListing();

  FacilityListing(const FacilityListing& from);

  inline FacilityListing& operator=(const FacilityListing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FacilityListing(FacilityListing&& from) noexcept
    : FacilityListing() {
    *this = ::std::move(from);
  }

  inline FacilityListing& operator=(FacilityListing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FacilityListing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FacilityListing* internal_default_instance() {
    return reinterpret_cast<const FacilityListing*>(
               &_FacilityListing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(FacilityListing* other);
  friend void swap(FacilityListing& a, FacilityListing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FacilityListing* New() const final {
    return CreateMaybeMessage<FacilityListing>(NULL);
  }

  FacilityListing* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FacilityListing>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FacilityListing& from);
  void MergeFrom(const FacilityListing& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FacilityListing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gomschema.Trade supply = 2;
  int supply_size() const;
  void clear_supply();
  static const int kSupplyFieldNumber = 2;
  ::gomschema::Trade* mutable_supply(int index);
  ::google::protobuf::RepeatedPtrField< ::gomschema::Trade >*
      mutable_supply();
  const ::gomschema::Trade& supply(int index) const;
  ::gomschema::Trade* add_supply();
  const ::google::protobuf::RepeatedPtrField< ::gomschema::Trade >&
      supply() const;

  // repeated .gomschema.Trade demand = 3;
  int demand_size() const;
  void clear_demand();
  static const int kDemandFieldNumber = 3;
  ::gomschema::Trade* mutable_demand(int index);
  ::google::protobuf::RepeatedPtrField< ::gomschema::Trade >*
      mutable_demand();
  const ::gomschema::Trade& demand(int index) const;
  ::gomschema::Trade* add_demand();
  const ::google::protobuf::RepeatedPtrField< ::gomschema::Trade >&
      demand() const;

  // required uint32 facility_id = 1;
  bool has_facility_id() const;
  void clear_facility_id();
  static const int kFacilityIdFieldNumber = 1;
  ::google::protobuf::uint32 facility_id() const;
  void set_facility_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:gomschema.FacilityListing)
 private:
  void set_has_facility_id();
  void clear_has_facility_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::gomschema::Trade > supply_;
  ::google::protobuf::RepeatedPtrField< ::gomschema::Trade > demand_;
  ::google::protobuf::uint32 facility_id_;
  friend struct ::protobuf_gomschema_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Header

// required .gomschema.Header.Class class = 1;
inline bool Header::has_class_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_class_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_class_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_class_() {
  class__ = 0;
  clear_has_class_();
}
inline ::gomschema::Header_Class Header::class_() const {
  // @@protoc_insertion_point(field_get:gomschema.Header.class)
  return static_cast< ::gomschema::Header_Class >(class__);
}
inline void Header::set_class_(::gomschema::Header_Class value) {
  assert(::gomschema::Header_Class_IsValid(value));
  set_has_class_();
  class__ = value;
  // @@protoc_insertion_point(field_set:gomschema.Header.class)
}

// repeated uint32 sizes = 2 [packed = true];
inline int Header::sizes_size() const {
  return sizes_.size();
}
inline void Header::clear_sizes() {
  sizes_.Clear();
}
inline ::google::protobuf::uint32 Header::sizes(int index) const {
  // @@protoc_insertion_point(field_get:gomschema.Header.sizes)
  return sizes_.Get(index);
}
inline void Header::set_sizes(int index, ::google::protobuf::uint32 value) {
  sizes_.Set(index, value);
  // @@protoc_insertion_point(field_set:gomschema.Header.sizes)
}
inline void Header::add_sizes(::google::protobuf::uint32 value) {
  sizes_.Add(value);
  // @@protoc_insertion_point(field_add:gomschema.Header.sizes)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Header::sizes() const {
  // @@protoc_insertion_point(field_list:gomschema.Header.sizes)
  return sizes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Header::mutable_sizes() {
  // @@protoc_insertion_point(field_mutable_list:gomschema.Header.sizes)
  return &sizes_;
}

// map<string, bytes> userdata = 3;
inline int Header::userdata_size() const {
  return userdata_.size();
}
inline void Header::clear_userdata() {
  userdata_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Header::userdata() const {
  // @@protoc_insertion_point(field_map:gomschema.Header.userdata)
  return userdata_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Header::mutable_userdata() {
  // @@protoc_insertion_point(field_mutable_map:gomschema.Header.userdata)
  return userdata_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Commodity

// required uint64 commodity_id = 1;
inline bool Commodity::has_commodity_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Commodity::set_has_commodity_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Commodity::clear_has_commodity_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Commodity::clear_commodity_id() {
  commodity_id_ = GOOGLE_ULONGLONG(0);
  clear_has_commodity_id();
}
inline ::google::protobuf::uint64 Commodity::commodity_id() const {
  // @@protoc_insertion_point(field_get:gomschema.Commodity.commodity_id)
  return commodity_id_;
}
inline void Commodity::set_commodity_id(::google::protobuf::uint64 value) {
  set_has_commodity_id();
  commodity_id_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Commodity.commodity_id)
}

// required string name = 2;
inline bool Commodity::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Commodity::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Commodity::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Commodity::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Commodity::name() const {
  // @@protoc_insertion_point(field_get:gomschema.Commodity.name)
  return name_.GetNoArena();
}
inline void Commodity::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gomschema.Commodity.name)
}
#if LANG_CXX11
inline void Commodity::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gomschema.Commodity.name)
}
#endif
inline void Commodity::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gomschema.Commodity.name)
}
inline void Commodity::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gomschema.Commodity.name)
}
inline ::std::string* Commodity::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:gomschema.Commodity.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Commodity::release_name() {
  // @@protoc_insertion_point(field_release:gomschema.Commodity.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Commodity::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:gomschema.Commodity.name)
}

// optional uint64 timestamp_utc = 3 [default = 0];
inline bool Commodity::has_timestamp_utc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Commodity::set_has_timestamp_utc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Commodity::clear_has_timestamp_utc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Commodity::clear_timestamp_utc() {
  timestamp_utc_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_utc();
}
inline ::google::protobuf::uint64 Commodity::timestamp_utc() const {
  // @@protoc_insertion_point(field_get:gomschema.Commodity.timestamp_utc)
  return timestamp_utc_;
}
inline void Commodity::set_timestamp_utc(::google::protobuf::uint64 value) {
  set_has_timestamp_utc();
  timestamp_utc_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Commodity.timestamp_utc)
}

// required .gomschema.Commodity.CommodityCategory category_id = 4;
inline bool Commodity::has_category_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Commodity::set_has_category_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Commodity::clear_has_category_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Commodity::clear_category_id() {
  category_id_ = 0;
  clear_has_category_id();
}
inline ::gomschema::Commodity_CommodityCategory Commodity::category_id() const {
  // @@protoc_insertion_point(field_get:gomschema.Commodity.category_id)
  return static_cast< ::gomschema::Commodity_CommodityCategory >(category_id_);
}
inline void Commodity::set_category_id(::gomschema::Commodity_CommodityCategory value) {
  assert(::gomschema::Commodity_CommodityCategory_IsValid(value));
  set_has_category_id();
  category_id_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Commodity.category_id)
}

// optional bool is_rare = 5 [default = false];
inline bool Commodity::has_is_rare() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Commodity::set_has_is_rare() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Commodity::clear_has_is_rare() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Commodity::clear_is_rare() {
  is_rare_ = false;
  clear_has_is_rare();
}
inline bool Commodity::is_rare() const {
  // @@protoc_insertion_point(field_get:gomschema.Commodity.is_rare)
  return is_rare_;
}
inline void Commodity::set_is_rare(bool value) {
  set_has_is_rare();
  is_rare_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Commodity.is_rare)
}

// optional bool is_non_marketable = 6 [default = false];
inline bool Commodity::has_is_non_marketable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Commodity::set_has_is_non_marketable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Commodity::clear_has_is_non_marketable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Commodity::clear_is_non_marketable() {
  is_non_marketable_ = false;
  clear_has_is_non_marketable();
}
inline bool Commodity::is_non_marketable() const {
  // @@protoc_insertion_point(field_get:gomschema.Commodity.is_non_marketable)
  return is_non_marketable_;
}
inline void Commodity::set_is_non_marketable(bool value) {
  set_has_is_non_marketable();
  is_non_marketable_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Commodity.is_non_marketable)
}

// optional uint32 average_cr = 7;
inline bool Commodity::has_average_cr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Commodity::set_has_average_cr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Commodity::clear_has_average_cr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Commodity::clear_average_cr() {
  average_cr_ = 0u;
  clear_has_average_cr();
}
inline ::google::protobuf::uint32 Commodity::average_cr() const {
  // @@protoc_insertion_point(field_get:gomschema.Commodity.average_cr)
  return average_cr_;
}
inline void Commodity::set_average_cr(::google::protobuf::uint32 value) {
  set_has_average_cr();
  average_cr_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Commodity.average_cr)
}

// map<string, bytes> userdata = 8;
inline int Commodity::userdata_size() const {
  return userdata_.size();
}
inline void Commodity::clear_userdata() {
  userdata_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Commodity::userdata() const {
  // @@protoc_insertion_point(field_map:gomschema.Commodity.userdata)
  return userdata_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Commodity::mutable_userdata() {
  // @@protoc_insertion_point(field_mutable_map:gomschema.Commodity.userdata)
  return userdata_.MutableMap();
}

// -------------------------------------------------------------------

// Coordinate

// required double x = 1;
inline bool Coordinate::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Coordinate::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Coordinate::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Coordinate::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Coordinate::x() const {
  // @@protoc_insertion_point(field_get:gomschema.Coordinate.x)
  return x_;
}
inline void Coordinate::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Coordinate.x)
}

// required double y = 2;
inline bool Coordinate::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Coordinate::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Coordinate::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Coordinate::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Coordinate::y() const {
  // @@protoc_insertion_point(field_get:gomschema.Coordinate.y)
  return y_;
}
inline void Coordinate::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Coordinate.y)
}

// required double z = 3;
inline bool Coordinate::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Coordinate::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Coordinate::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Coordinate::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Coordinate::z() const {
  // @@protoc_insertion_point(field_get:gomschema.Coordinate.z)
  return z_;
}
inline void Coordinate::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Coordinate.z)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// System

// required uint32 id = 1;
inline bool System::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void System::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void System::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void System::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 System::id() const {
  // @@protoc_insertion_point(field_get:gomschema.System.id)
  return id_;
}
inline void System::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:gomschema.System.id)
}

// required string name = 2;
inline bool System::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void System::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void System::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void System::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& System::name() const {
  // @@protoc_insertion_point(field_get:gomschema.System.name)
  return name_.GetNoArena();
}
inline void System::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gomschema.System.name)
}
#if LANG_CXX11
inline void System::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gomschema.System.name)
}
#endif
inline void System::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gomschema.System.name)
}
inline void System::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gomschema.System.name)
}
inline ::std::string* System::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:gomschema.System.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* System::release_name() {
  // @@protoc_insertion_point(field_release:gomschema.System.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void System::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:gomschema.System.name)
}

// optional uint64 timestamp_utc = 3 [default = 0];
inline bool System::has_timestamp_utc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void System::set_has_timestamp_utc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void System::clear_has_timestamp_utc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void System::clear_timestamp_utc() {
  timestamp_utc_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_utc();
}
inline ::google::protobuf::uint64 System::timestamp_utc() const {
  // @@protoc_insertion_point(field_get:gomschema.System.timestamp_utc)
  return timestamp_utc_;
}
inline void System::set_timestamp_utc(::google::protobuf::uint64 value) {
  set_has_timestamp_utc();
  timestamp_utc_ = value;
  // @@protoc_insertion_point(field_set:gomschema.System.timestamp_utc)
}

// required .gomschema.Coordinate position = 4;
inline bool System::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void System::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void System::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void System::clear_position() {
  if (position_ != NULL) position_->Clear();
  clear_has_position();
}
inline const ::gomschema::Coordinate& System::_internal_position() const {
  return *position_;
}
inline const ::gomschema::Coordinate& System::position() const {
  const ::gomschema::Coordinate* p = position_;
  // @@protoc_insertion_point(field_get:gomschema.System.position)
  return p != NULL ? *p : *reinterpret_cast<const ::gomschema::Coordinate*>(
      &::gomschema::_Coordinate_default_instance_);
}
inline ::gomschema::Coordinate* System::release_position() {
  // @@protoc_insertion_point(field_release:gomschema.System.position)
  clear_has_position();
  ::gomschema::Coordinate* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::gomschema::Coordinate* System::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::gomschema::Coordinate>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gomschema.System.position)
  return position_;
}
inline void System::set_allocated_position(::gomschema::Coordinate* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:gomschema.System.position)
}

// optional bool populated = 5 [default = true];
inline bool System::has_populated() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void System::set_has_populated() {
  _has_bits_[0] |= 0x00000040u;
}
inline void System::clear_has_populated() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void System::clear_populated() {
  populated_ = true;
  clear_has_populated();
}
inline bool System::populated() const {
  // @@protoc_insertion_point(field_get:gomschema.System.populated)
  return populated_;
}
inline void System::set_populated(bool value) {
  set_has_populated();
  populated_ = value;
  // @@protoc_insertion_point(field_set:gomschema.System.populated)
}

// optional bool needs_permit = 6 [default = false];
inline bool System::has_needs_permit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void System::set_has_needs_permit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void System::clear_has_needs_permit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void System::clear_needs_permit() {
  needs_permit_ = false;
  clear_has_needs_permit();
}
inline bool System::needs_permit() const {
  // @@protoc_insertion_point(field_get:gomschema.System.needs_permit)
  return needs_permit_;
}
inline void System::set_needs_permit(bool value) {
  set_has_needs_permit();
  needs_permit_ = value;
  // @@protoc_insertion_point(field_set:gomschema.System.needs_permit)
}

// optional .gomschema.SecurityLevel security_level = 7 [default = SecurityMedium];
inline bool System::has_security_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void System::set_has_security_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void System::clear_has_security_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void System::clear_security_level() {
  security_level_ = 3;
  clear_has_security_level();
}
inline ::gomschema::SecurityLevel System::security_level() const {
  // @@protoc_insertion_point(field_get:gomschema.System.security_level)
  return static_cast< ::gomschema::SecurityLevel >(security_level_);
}
inline void System::set_security_level(::gomschema::SecurityLevel value) {
  assert(::gomschema::SecurityLevel_IsValid(value));
  set_has_security_level();
  security_level_ = value;
  // @@protoc_insertion_point(field_set:gomschema.System.security_level)
}

// optional .gomschema.GovernmentType government = 8 [default = GovCorporate];
inline bool System::has_government() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void System::set_has_government() {
  _has_bits_[0] |= 0x00000100u;
}
inline void System::clear_has_government() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void System::clear_government() {
  government_ = 5;
  clear_has_government();
}
inline ::gomschema::GovernmentType System::government() const {
  // @@protoc_insertion_point(field_get:gomschema.System.government)
  return static_cast< ::gomschema::GovernmentType >(government_);
}
inline void System::set_government(::gomschema::GovernmentType value) {
  assert(::gomschema::GovernmentType_IsValid(value));
  set_has_government();
  government_ = value;
  // @@protoc_insertion_point(field_set:gomschema.System.government)
}

// optional .gomschema.AllegianceType allegiance = 9 [default = AllegIndependent];
inline bool System::has_allegiance() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void System::set_has_allegiance() {
  _has_bits_[0] |= 0x00000200u;
}
inline void System::clear_has_allegiance() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void System::clear_allegiance() {
  allegiance_ = 4;
  clear_has_allegiance();
}
inline ::gomschema::AllegianceType System::allegiance() const {
  // @@protoc_insertion_point(field_get:gomschema.System.allegiance)
  return static_cast< ::gomschema::AllegianceType >(allegiance_);
}
inline void System::set_allegiance(::gomschema::AllegianceType value) {
  assert(::gomschema::AllegianceType_IsValid(value));
  set_has_allegiance();
  allegiance_ = value;
  // @@protoc_insertion_point(field_set:gomschema.System.allegiance)
}

// optional uint64 ed_address = 10 [default = 0];
inline bool System::has_ed_address() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void System::set_has_ed_address() {
  _has_bits_[0] |= 0x00000020u;
}
inline void System::clear_has_ed_address() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void System::clear_ed_address() {
  ed_address_ = GOOGLE_ULONGLONG(0);
  clear_has_ed_address();
}
inline ::google::protobuf::uint64 System::ed_address() const {
  // @@protoc_insertion_point(field_get:gomschema.System.ed_address)
  return ed_address_;
}
inline void System::set_ed_address(::google::protobuf::uint64 value) {
  set_has_ed_address();
  ed_address_ = value;
  // @@protoc_insertion_point(field_set:gomschema.System.ed_address)
}

// map<string, bytes> userdata = 11;
inline int System::userdata_size() const {
  return userdata_.size();
}
inline void System::clear_userdata() {
  userdata_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
System::userdata() const {
  // @@protoc_insertion_point(field_map:gomschema.System.userdata)
  return userdata_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
System::mutable_userdata() {
  // @@protoc_insertion_point(field_mutable_map:gomschema.System.userdata)
  return userdata_.MutableMap();
}

// -------------------------------------------------------------------

// Services

// optional bool has_market = 1 [default = true];
inline bool Services::has_has_market() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Services::set_has_has_market() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Services::clear_has_has_market() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Services::clear_has_market() {
  has_market_ = true;
  clear_has_has_market();
}
inline bool Services::has_market() const {
  // @@protoc_insertion_point(field_get:gomschema.Services.has_market)
  return has_market_;
}
inline void Services::set_has_market(bool value) {
  set_has_has_market();
  has_market_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Services.has_market)
}

// required bool has_black_market = 2;
inline bool Services::has_has_black_market() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Services::set_has_has_black_market() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Services::clear_has_has_black_market() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Services::clear_has_black_market() {
  has_black_market_ = false;
  clear_has_has_black_market();
}
inline bool Services::has_black_market() const {
  // @@protoc_insertion_point(field_get:gomschema.Services.has_black_market)
  return has_black_market_;
}
inline void Services::set_has_black_market(bool value) {
  set_has_has_black_market();
  has_black_market_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Services.has_black_market)
}

// optional bool has_refuel = 3 [default = true];
inline bool Services::has_has_refuel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Services::set_has_has_refuel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Services::clear_has_has_refuel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Services::clear_has_refuel() {
  has_refuel_ = true;
  clear_has_has_refuel();
}
inline bool Services::has_refuel() const {
  // @@protoc_insertion_point(field_get:gomschema.Services.has_refuel)
  return has_refuel_;
}
inline void Services::set_has_refuel(bool value) {
  set_has_has_refuel();
  has_refuel_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Services.has_refuel)
}

// optional bool has_repair = 4 [default = true];
inline bool Services::has_has_repair() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Services::set_has_has_repair() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Services::clear_has_has_repair() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Services::clear_has_repair() {
  has_repair_ = true;
  clear_has_has_repair();
}
inline bool Services::has_repair() const {
  // @@protoc_insertion_point(field_get:gomschema.Services.has_repair)
  return has_repair_;
}
inline void Services::set_has_repair(bool value) {
  set_has_has_repair();
  has_repair_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Services.has_repair)
}

// optional bool has_rearm = 5 [default = true];
inline bool Services::has_has_rearm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Services::set_has_has_rearm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Services::clear_has_has_rearm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Services::clear_has_rearm() {
  has_rearm_ = true;
  clear_has_has_rearm();
}
inline bool Services::has_rearm() const {
  // @@protoc_insertion_point(field_get:gomschema.Services.has_rearm)
  return has_rearm_;
}
inline void Services::set_has_rearm(bool value) {
  set_has_has_rearm();
  has_rearm_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Services.has_rearm)
}

// required bool has_outfitting = 6;
inline bool Services::has_has_outfitting() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Services::set_has_has_outfitting() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Services::clear_has_has_outfitting() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Services::clear_has_outfitting() {
  has_outfitting_ = false;
  clear_has_has_outfitting();
}
inline bool Services::has_outfitting() const {
  // @@protoc_insertion_point(field_get:gomschema.Services.has_outfitting)
  return has_outfitting_;
}
inline void Services::set_has_outfitting(bool value) {
  set_has_has_outfitting();
  has_outfitting_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Services.has_outfitting)
}

// required bool has_shipyard = 7;
inline bool Services::has_has_shipyard() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Services::set_has_has_shipyard() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Services::clear_has_has_shipyard() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Services::clear_has_shipyard() {
  has_shipyard_ = false;
  clear_has_has_shipyard();
}
inline bool Services::has_shipyard() const {
  // @@protoc_insertion_point(field_get:gomschema.Services.has_shipyard)
  return has_shipyard_;
}
inline void Services::set_has_shipyard(bool value) {
  set_has_has_shipyard();
  has_shipyard_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Services.has_shipyard)
}

// optional bool has_docking = 8 [default = true];
inline bool Services::has_has_docking() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Services::set_has_has_docking() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Services::clear_has_has_docking() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Services::clear_has_docking() {
  has_docking_ = true;
  clear_has_has_docking();
}
inline bool Services::has_docking() const {
  // @@protoc_insertion_point(field_get:gomschema.Services.has_docking)
  return has_docking_;
}
inline void Services::set_has_docking(bool value) {
  set_has_has_docking();
  has_docking_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Services.has_docking)
}

// optional bool has_commodities = 9 [default = true];
inline bool Services::has_has_commodities() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Services::set_has_has_commodities() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Services::clear_has_has_commodities() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Services::clear_has_commodities() {
  has_commodities_ = true;
  clear_has_has_commodities();
}
inline bool Services::has_commodities() const {
  // @@protoc_insertion_point(field_get:gomschema.Services.has_commodities)
  return has_commodities_;
}
inline void Services::set_has_commodities(bool value) {
  set_has_has_commodities();
  has_commodities_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Services.has_commodities)
}

// required bool is_planetary = 10 [default = true];
inline bool Services::has_is_planetary() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Services::set_has_is_planetary() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Services::clear_has_is_planetary() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Services::clear_is_planetary() {
  is_planetary_ = true;
  clear_has_is_planetary();
}
inline bool Services::is_planetary() const {
  // @@protoc_insertion_point(field_get:gomschema.Services.is_planetary)
  return is_planetary_;
}
inline void Services::set_is_planetary(bool value) {
  set_has_is_planetary();
  is_planetary_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Services.is_planetary)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Facility

// required uint32 id = 1;
inline bool Facility::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Facility::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Facility::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Facility::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Facility::id() const {
  // @@protoc_insertion_point(field_get:gomschema.Facility.id)
  return id_;
}
inline void Facility::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Facility.id)
}

// required uint32 system_id = 2;
inline bool Facility::has_system_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Facility::set_has_system_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Facility::clear_has_system_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Facility::clear_system_id() {
  system_id_ = 0u;
  clear_has_system_id();
}
inline ::google::protobuf::uint32 Facility::system_id() const {
  // @@protoc_insertion_point(field_get:gomschema.Facility.system_id)
  return system_id_;
}
inline void Facility::set_system_id(::google::protobuf::uint32 value) {
  set_has_system_id();
  system_id_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Facility.system_id)
}

// required string name = 3;
inline bool Facility::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Facility::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Facility::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Facility::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Facility::name() const {
  // @@protoc_insertion_point(field_get:gomschema.Facility.name)
  return name_.GetNoArena();
}
inline void Facility::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gomschema.Facility.name)
}
#if LANG_CXX11
inline void Facility::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gomschema.Facility.name)
}
#endif
inline void Facility::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gomschema.Facility.name)
}
inline void Facility::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gomschema.Facility.name)
}
inline ::std::string* Facility::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:gomschema.Facility.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Facility::release_name() {
  // @@protoc_insertion_point(field_release:gomschema.Facility.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Facility::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:gomschema.Facility.name)
}

// optional uint64 timestamp_utc = 4 [default = 0];
inline bool Facility::has_timestamp_utc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Facility::set_has_timestamp_utc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Facility::clear_has_timestamp_utc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Facility::clear_timestamp_utc() {
  timestamp_utc_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_utc();
}
inline ::google::protobuf::uint64 Facility::timestamp_utc() const {
  // @@protoc_insertion_point(field_get:gomschema.Facility.timestamp_utc)
  return timestamp_utc_;
}
inline void Facility::set_timestamp_utc(::google::protobuf::uint64 value) {
  set_has_timestamp_utc();
  timestamp_utc_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Facility.timestamp_utc)
}

// optional .gomschema.FacilityType facility_type = 5 [default = FTPlanetaryOutpost];
inline bool Facility::has_facility_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Facility::set_has_facility_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Facility::clear_has_facility_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Facility::clear_facility_type() {
  facility_type_ = 10;
  clear_has_facility_type();
}
inline ::gomschema::FacilityType Facility::facility_type() const {
  // @@protoc_insertion_point(field_get:gomschema.Facility.facility_type)
  return static_cast< ::gomschema::FacilityType >(facility_type_);
}
inline void Facility::set_facility_type(::gomschema::FacilityType value) {
  assert(::gomschema::FacilityType_IsValid(value));
  set_has_facility_type();
  facility_type_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Facility.facility_type)
}

// required .gomschema.Services services = 6;
inline bool Facility::has_services() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Facility::set_has_services() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Facility::clear_has_services() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Facility::clear_services() {
  if (services_ != NULL) services_->Clear();
  clear_has_services();
}
inline const ::gomschema::Services& Facility::_internal_services() const {
  return *services_;
}
inline const ::gomschema::Services& Facility::services() const {
  const ::gomschema::Services* p = services_;
  // @@protoc_insertion_point(field_get:gomschema.Facility.services)
  return p != NULL ? *p : *reinterpret_cast<const ::gomschema::Services*>(
      &::gomschema::_Services_default_instance_);
}
inline ::gomschema::Services* Facility::release_services() {
  // @@protoc_insertion_point(field_release:gomschema.Facility.services)
  clear_has_services();
  ::gomschema::Services* temp = services_;
  services_ = NULL;
  return temp;
}
inline ::gomschema::Services* Facility::mutable_services() {
  set_has_services();
  if (services_ == NULL) {
    auto* p = CreateMaybeMessage<::gomschema::Services>(GetArenaNoVirtual());
    services_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gomschema.Facility.services)
  return services_;
}
inline void Facility::set_allocated_services(::gomschema::Services* services) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete services_;
  }
  if (services) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      services = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, services, submessage_arena);
    }
    set_has_services();
  } else {
    clear_has_services();
  }
  services_ = services;
  // @@protoc_insertion_point(field_set_allocated:gomschema.Facility.services)
}

// optional .gomschema.PadSize pad_size = 7 [default = PadMedium];
inline bool Facility::has_pad_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Facility::set_has_pad_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Facility::clear_has_pad_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Facility::clear_pad_size() {
  pad_size_ = 2;
  clear_has_pad_size();
}
inline ::gomschema::PadSize Facility::pad_size() const {
  // @@protoc_insertion_point(field_get:gomschema.Facility.pad_size)
  return static_cast< ::gomschema::PadSize >(pad_size_);
}
inline void Facility::set_pad_size(::gomschema::PadSize value) {
  assert(::gomschema::PadSize_IsValid(value));
  set_has_pad_size();
  pad_size_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Facility.pad_size)
}

// optional uint32 ls_from_star = 8;
inline bool Facility::has_ls_from_star() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Facility::set_has_ls_from_star() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Facility::clear_has_ls_from_star() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Facility::clear_ls_from_star() {
  ls_from_star_ = 0u;
  clear_has_ls_from_star();
}
inline ::google::protobuf::uint32 Facility::ls_from_star() const {
  // @@protoc_insertion_point(field_get:gomschema.Facility.ls_from_star)
  return ls_from_star_;
}
inline void Facility::set_ls_from_star(::google::protobuf::uint32 value) {
  set_has_ls_from_star();
  ls_from_star_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Facility.ls_from_star)
}

// optional .gomschema.GovernmentType government = 9 [default = GovCorporate];
inline bool Facility::has_government() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Facility::set_has_government() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Facility::clear_has_government() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Facility::clear_government() {
  government_ = 5;
  clear_has_government();
}
inline ::gomschema::GovernmentType Facility::government() const {
  // @@protoc_insertion_point(field_get:gomschema.Facility.government)
  return static_cast< ::gomschema::GovernmentType >(government_);
}
inline void Facility::set_government(::gomschema::GovernmentType value) {
  assert(::gomschema::GovernmentType_IsValid(value));
  set_has_government();
  government_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Facility.government)
}

// optional .gomschema.AllegianceType allegiance = 10 [default = AllegIndependent];
inline bool Facility::has_allegiance() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Facility::set_has_allegiance() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Facility::clear_has_allegiance() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Facility::clear_allegiance() {
  allegiance_ = 4;
  clear_has_allegiance();
}
inline ::gomschema::AllegianceType Facility::allegiance() const {
  // @@protoc_insertion_point(field_get:gomschema.Facility.allegiance)
  return static_cast< ::gomschema::AllegianceType >(allegiance_);
}
inline void Facility::set_allegiance(::gomschema::AllegianceType value) {
  assert(::gomschema::AllegianceType_IsValid(value));
  set_has_allegiance();
  allegiance_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Facility.allegiance)
}

// optional uint64 ed_market_id = 11 [default = 0];
inline bool Facility::has_ed_market_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Facility::set_has_ed_market_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Facility::clear_has_ed_market_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Facility::clear_ed_market_id() {
  ed_market_id_ = GOOGLE_ULONGLONG(0);
  clear_has_ed_market_id();
}
inline ::google::protobuf::uint64 Facility::ed_market_id() const {
  // @@protoc_insertion_point(field_get:gomschema.Facility.ed_market_id)
  return ed_market_id_;
}
inline void Facility::set_ed_market_id(::google::protobuf::uint64 value) {
  set_has_ed_market_id();
  ed_market_id_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Facility.ed_market_id)
}

// map<string, bytes> userdata = 12;
inline int Facility::userdata_size() const {
  return userdata_.size();
}
inline void Facility::clear_userdata() {
  userdata_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
Facility::userdata() const {
  // @@protoc_insertion_point(field_map:gomschema.Facility.userdata)
  return userdata_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
Facility::mutable_userdata() {
  // @@protoc_insertion_point(field_mutable_map:gomschema.Facility.userdata)
  return userdata_.MutableMap();
}

// -------------------------------------------------------------------

// Trade

// required uint32 commodity_id = 1;
inline bool Trade::has_commodity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trade::set_has_commodity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trade::clear_has_commodity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trade::clear_commodity_id() {
  commodity_id_ = 0u;
  clear_has_commodity_id();
}
inline ::google::protobuf::uint32 Trade::commodity_id() const {
  // @@protoc_insertion_point(field_get:gomschema.Trade.commodity_id)
  return commodity_id_;
}
inline void Trade::set_commodity_id(::google::protobuf::uint32 value) {
  set_has_commodity_id();
  commodity_id_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Trade.commodity_id)
}

// required uint32 units = 2;
inline bool Trade::has_units() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trade::set_has_units() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trade::clear_has_units() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trade::clear_units() {
  units_ = 0u;
  clear_has_units();
}
inline ::google::protobuf::uint32 Trade::units() const {
  // @@protoc_insertion_point(field_get:gomschema.Trade.units)
  return units_;
}
inline void Trade::set_units(::google::protobuf::uint32 value) {
  set_has_units();
  units_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Trade.units)
}

// required int32 credits = 3;
inline bool Trade::has_credits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Trade::set_has_credits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Trade::clear_has_credits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Trade::clear_credits() {
  credits_ = 0;
  clear_has_credits();
}
inline ::google::protobuf::int32 Trade::credits() const {
  // @@protoc_insertion_point(field_get:gomschema.Trade.credits)
  return credits_;
}
inline void Trade::set_credits(::google::protobuf::int32 value) {
  set_has_credits();
  credits_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Trade.credits)
}

// optional uint64 timestamp_utc = 4 [default = 0];
inline bool Trade::has_timestamp_utc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Trade::set_has_timestamp_utc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Trade::clear_has_timestamp_utc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Trade::clear_timestamp_utc() {
  timestamp_utc_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_utc();
}
inline ::google::protobuf::uint64 Trade::timestamp_utc() const {
  // @@protoc_insertion_point(field_get:gomschema.Trade.timestamp_utc)
  return timestamp_utc_;
}
inline void Trade::set_timestamp_utc(::google::protobuf::uint64 value) {
  set_has_timestamp_utc();
  timestamp_utc_ = value;
  // @@protoc_insertion_point(field_set:gomschema.Trade.timestamp_utc)
}

// -------------------------------------------------------------------

// FacilityListing

// required uint32 facility_id = 1;
inline bool FacilityListing::has_facility_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FacilityListing::set_has_facility_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FacilityListing::clear_has_facility_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FacilityListing::clear_facility_id() {
  facility_id_ = 0u;
  clear_has_facility_id();
}
inline ::google::protobuf::uint32 FacilityListing::facility_id() const {
  // @@protoc_insertion_point(field_get:gomschema.FacilityListing.facility_id)
  return facility_id_;
}
inline void FacilityListing::set_facility_id(::google::protobuf::uint32 value) {
  set_has_facility_id();
  facility_id_ = value;
  // @@protoc_insertion_point(field_set:gomschema.FacilityListing.facility_id)
}

// repeated .gomschema.Trade supply = 2;
inline int FacilityListing::supply_size() const {
  return supply_.size();
}
inline void FacilityListing::clear_supply() {
  supply_.Clear();
}
inline ::gomschema::Trade* FacilityListing::mutable_supply(int index) {
  // @@protoc_insertion_point(field_mutable:gomschema.FacilityListing.supply)
  return supply_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::gomschema::Trade >*
FacilityListing::mutable_supply() {
  // @@protoc_insertion_point(field_mutable_list:gomschema.FacilityListing.supply)
  return &supply_;
}
inline const ::gomschema::Trade& FacilityListing::supply(int index) const {
  // @@protoc_insertion_point(field_get:gomschema.FacilityListing.supply)
  return supply_.Get(index);
}
inline ::gomschema::Trade* FacilityListing::add_supply() {
  // @@protoc_insertion_point(field_add:gomschema.FacilityListing.supply)
  return supply_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gomschema::Trade >&
FacilityListing::supply() const {
  // @@protoc_insertion_point(field_list:gomschema.FacilityListing.supply)
  return supply_;
}

// repeated .gomschema.Trade demand = 3;
inline int FacilityListing::demand_size() const {
  return demand_.size();
}
inline void FacilityListing::clear_demand() {
  demand_.Clear();
}
inline ::gomschema::Trade* FacilityListing::mutable_demand(int index) {
  // @@protoc_insertion_point(field_mutable:gomschema.FacilityListing.demand)
  return demand_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::gomschema::Trade >*
FacilityListing::mutable_demand() {
  // @@protoc_insertion_point(field_mutable_list:gomschema.FacilityListing.demand)
  return &demand_;
}
inline const ::gomschema::Trade& FacilityListing::demand(int index) const {
  // @@protoc_insertion_point(field_get:gomschema.FacilityListing.demand)
  return demand_.Get(index);
}
inline ::gomschema::Trade* FacilityListing::add_demand() {
  // @@protoc_insertion_point(field_add:gomschema.FacilityListing.demand)
  return demand_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gomschema::Trade >&
FacilityListing::demand() const {
  // @@protoc_insertion_point(field_list:gomschema.FacilityListing.demand)
  return demand_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gomschema

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::gomschema::Header_Class> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gomschema::Header_Class>() {
  return ::gomschema::Header_Class_descriptor();
}
template <> struct is_proto_enum< ::gomschema::Commodity_CommodityCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gomschema::Commodity_CommodityCategory>() {
  return ::gomschema::Commodity_CommodityCategory_descriptor();
}
template <> struct is_proto_enum< ::gomschema::GovernmentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gomschema::GovernmentType>() {
  return ::gomschema::GovernmentType_descriptor();
}
template <> struct is_proto_enum< ::gomschema::AllegianceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gomschema::AllegianceType>() {
  return ::gomschema::AllegianceType_descriptor();
}
template <> struct is_proto_enum< ::gomschema::SecurityLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gomschema::SecurityLevel>() {
  return ::gomschema::SecurityLevel_descriptor();
}
template <> struct is_proto_enum< ::gomschema::FacilityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gomschema::FacilityType>() {
  return ::gomschema::FacilityType_descriptor();
}
template <> struct is_proto_enum< ::gomschema::PadSize> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gomschema::PadSize>() {
  return ::gomschema::PadSize_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_gomschema_2eproto
