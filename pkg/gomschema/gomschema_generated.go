// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package gomschema

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Government is an enumeration of government types reduced to a single field.
type Government = int8
const (
	GovernmentNone Government = 0
	GovernmentAnarchy Government = 1
	GovernmentCommunism Government = 2
	GovernmentConfederacy Government = 3
	Governmentooperative Government = 4
	GovernmentCorporate Government = 5
	Governmentemocracy Government = 6
	GovernmentDictatorship Government = 7
	GovernmentFeudal Government = 8
	GovernmentPatronage Government = 9
	GovernmentPrison Government = 10
	GovernmentPrisonColony Government = 11
	GovernmentTheocracy Government = 12
)

var EnumNamesGovernment = map[Government]string{
	GovernmentNone:"None",
	GovernmentAnarchy:"Anarchy",
	GovernmentCommunism:"Communism",
	GovernmentConfederacy:"Confederacy",
	Governmentooperative:"ooperative",
	GovernmentCorporate:"Corporate",
	Governmentemocracy:"emocracy",
	GovernmentDictatorship:"Dictatorship",
	GovernmentFeudal:"Feudal",
	GovernmentPatronage:"Patronage",
	GovernmentPrison:"Prison",
	GovernmentPrisonColony:"PrisonColony",
	GovernmentTheocracy:"Theocracy",
}

/// Allegiance is an enumeration of allegiance types reduced to a single field.
type Allegiance = int8
const (
	AllegianceNone Allegiance = 0
	AllegianceAlliance Allegiance = 1
	AllegianceEmpire Allegiance = 2
	AllegianceFederation Allegiance = 3
	AllegianceIndependent Allegiance = 4
	AllegiancePilotsFederation Allegiance = 5
)

var EnumNamesAllegiance = map[Allegiance]string{
	AllegianceNone:"None",
	AllegianceAlliance:"Alliance",
	AllegianceEmpire:"Empire",
	AllegianceFederation:"Federation",
	AllegianceIndependent:"Independent",
	AllegiancePilotsFederation:"PilotsFederation",
}

/// Security level is system-specific and determines how aggressive law enforcement is.
type SecurityLevel = int8
const (
	SecurityLevelNone SecurityLevel = 0
	SecurityLevelAnarchy SecurityLevel = 1
	SecurityLevelLow SecurityLevel = 2
	SecurityLevelMedium SecurityLevel = 3
	SecurityLevelHigh SecurityLevel = 4
)

var EnumNamesSecurityLevel = map[SecurityLevel]string{
	SecurityLevelNone:"None",
	SecurityLevelAnarchy:"Anarchy",
	SecurityLevelLow:"Low",
	SecurityLevelMedium:"Medium",
	SecurityLevelHigh:"High",
}

type FacilityType = int8
const (
	FacilityTypeNone FacilityType = 0
	FacilityTypeCivilianOutpost FacilityType = 1
	FacilityTypeCommercialOutpost FacilityType = 2
	FacilityTypeCoriolisStarport FacilityType = 3
	FacilityTypeIndustrialOutpost FacilityType = 4
	FacilityTypeMilitaryOutpost FacilityType = 5
	FacilityTypeMiningOutpost FacilityType = 6
	FacilityTypeOcellusStarport FacilityType = 7
	FacilityTypeOrbisStarport FacilityType = 8
	FacilityTypeScientificOutpost FacilityType = 9
	FacilityTypePlanetaryOutpost FacilityType = 10
	FacilityTypePlanetaryPort FacilityType = 11
	FacilityTypePlanetarySettlement FacilityType = 12
	FacilityTypeMegaship FacilityType = 13
	FacilityTypeAsteroidBase FacilityType = 14
	FacilityTypeFleetCarrier FacilityType = 15
)

var EnumNamesFacilityType = map[FacilityType]string{
	FacilityTypeNone:"None",
	FacilityTypeCivilianOutpost:"CivilianOutpost",
	FacilityTypeCommercialOutpost:"CommercialOutpost",
	FacilityTypeCoriolisStarport:"CoriolisStarport",
	FacilityTypeIndustrialOutpost:"IndustrialOutpost",
	FacilityTypeMilitaryOutpost:"MilitaryOutpost",
	FacilityTypeMiningOutpost:"MiningOutpost",
	FacilityTypeOcellusStarport:"OcellusStarport",
	FacilityTypeOrbisStarport:"OrbisStarport",
	FacilityTypeScientificOutpost:"ScientificOutpost",
	FacilityTypePlanetaryOutpost:"PlanetaryOutpost",
	FacilityTypePlanetaryPort:"PlanetaryPort",
	FacilityTypePlanetarySettlement:"PlanetarySettlement",
	FacilityTypeMegaship:"Megaship",
	FacilityTypeAsteroidBase:"AsteroidBase",
	FacilityTypeFleetCarrier:"FleetCarrier",
}

type LandingPad = int8
const (
	LandingPadNone LandingPad = 0
	LandingPadSmall LandingPad = 1
	LandingPadMedium LandingPad = 2
	LandingPadLarge LandingPad = 3
)

var EnumNamesLandingPad = map[LandingPad]string{
	LandingPadNone:"None",
	LandingPadSmall:"Small",
	LandingPadMedium:"Medium",
	LandingPadLarge:"Large",
}

type CommodityType = int8
const (
	CommodityTypeNone CommodityType = 0
	CommodityTypeChemicals CommodityType = 1
	CommodityTypeConsumerItems CommodityType = 2
	CommodityTypeLegalDrugs CommodityType = 3
	CommodityTypeFoods CommodityType = 4
	CommodityTypeIndustrialMaterials CommodityType = 5
	CommodityTypeMachinery CommodityType = 6
	CommodityTypeMedicines CommodityType = 7
	CommodityTypeMetals CommodityType = 8
	CommodityTypeMinerals CommodityType = 9
	CommodityTypeSlavery CommodityType = 10
	CommodityTypeTechnology CommodityType = 11
	CommodityTypeTextiles CommodityType = 12
	CommodityTypeWaste CommodityType = 13
	CommodityTypeWeapons CommodityType = 14
	CommodityTypeUnknown CommodityType = 15
	CommodityTypeSalvage CommodityType = 16
)

var EnumNamesCommodityType = map[CommodityType]string{
	CommodityTypeNone:"None",
	CommodityTypeChemicals:"Chemicals",
	CommodityTypeConsumerItems:"ConsumerItems",
	CommodityTypeLegalDrugs:"LegalDrugs",
	CommodityTypeFoods:"Foods",
	CommodityTypeIndustrialMaterials:"IndustrialMaterials",
	CommodityTypeMachinery:"Machinery",
	CommodityTypeMedicines:"Medicines",
	CommodityTypeMetals:"Metals",
	CommodityTypeMinerals:"Minerals",
	CommodityTypeSlavery:"Slavery",
	CommodityTypeTechnology:"Technology",
	CommodityTypeTextiles:"Textiles",
	CommodityTypeWaste:"Waste",
	CommodityTypeWeapons:"Weapons",
	CommodityTypeUnknown:"Unknown",
	CommodityTypeSalvage:"Salvage",
}

/// Commodity is a type of item that can be traded within the game. At the moment,
/// the categories are small enough I decided to just enumerate them right here.
type Commodity struct {
	_tab flatbuffers.Table
}

func GetRootAsCommodity(buf []byte, offset flatbuffers.UOffsetT) *Commodity {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Commodity{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Commodity) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Commodity) Table() flatbuffers.Table {
	return rcv._tab
}

/// Elite Dangerous' internal ID for the commodity acts as the key.
func (rcv *Commodity) CommodityId() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// Elite Dangerous' internal ID for the commodity acts as the key.
func (rcv *Commodity) MutateCommodityId(n uint64) bool {
	return rcv._tab.MutateUint64Slot(4, n)
}

/// Name can be localized as long as the English name is preserved for hashing.
func (rcv *Commodity) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Name can be localized as long as the English name is preserved for hashing.
/// What type of item is this.
func (rcv *Commodity) CategoryId() CommodityType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt8(o + rcv._tab.Pos)
	}
	return 0
}

/// What type of item is this.
func (rcv *Commodity) MutateCategoryId(n CommodityType) bool {
	return rcv._tab.MutateInt8Slot(8, n)
}

/// Whether the item is known to be rare.
func (rcv *Commodity) IsRare() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Whether the item is known to be rare.
func (rcv *Commodity) MutateIsRare(n bool) bool {
	return rcv._tab.MutateBoolSlot(10, n)
}

/// Whether the item is known to be marketable.
func (rcv *Commodity) IsNonMarketable() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Whether the item is known to be marketable.
func (rcv *Commodity) MutateIsNonMarketable(n bool) bool {
	return rcv._tab.MutateBoolSlot(12, n)
}

/// The average galactic market price in credits.
func (rcv *Commodity) AverageCr() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// The average galactic market price in credits.
func (rcv *Commodity) MutateAverageCr(n uint32) bool {
	return rcv._tab.MutateUint32Slot(14, n)
}

func CommodityStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func CommodityAddCommodityId(builder *flatbuffers.Builder, commodityId uint64) {
	builder.PrependUint64Slot(0, commodityId, 0)
}
func CommodityAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func CommodityAddCategoryId(builder *flatbuffers.Builder, categoryId int8) {
	builder.PrependInt8Slot(2, categoryId, 0)
}
func CommodityAddIsRare(builder *flatbuffers.Builder, isRare bool) {
	builder.PrependBoolSlot(3, isRare, false)
}
func CommodityAddIsNonMarketable(builder *flatbuffers.Builder, isNonMarketable bool) {
	builder.PrependBoolSlot(4, isNonMarketable, false)
}
func CommodityAddAverageCr(builder *flatbuffers.Builder, averageCr uint32) {
	builder.PrependUint32Slot(5, averageCr, 0)
}
func CommodityEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
/// Trade is a discrete entry for a Commodity that is or can be traded at with
/// a number of units and a value.
type Trade struct {
	_tab flatbuffers.Struct
}

func (rcv *Trade) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Trade) Table() flatbuffers.Table {
	return rcv._tab.Table
}

/// Which commodity this describes.
func (rcv *Trade) CommodityId() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}
/// Which commodity this describes.
func (rcv *Trade) MutateCommodityId(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(0), n)
}

/// How many units
func (rcv *Trade) Units() uint32 {
	return rcv._tab.GetUint32(rcv._tab.Pos + flatbuffers.UOffsetT(8))
}
/// How many units
func (rcv *Trade) MutateUnits(n uint32) bool {
	return rcv._tab.MutateUint32(rcv._tab.Pos+flatbuffers.UOffsetT(8), n)
}

/// How many credits
func (rcv *Trade) Credits() uint16 {
	return rcv._tab.GetUint16(rcv._tab.Pos + flatbuffers.UOffsetT(12))
}
/// How many credits
func (rcv *Trade) MutateCredits(n uint16) bool {
	return rcv._tab.MutateUint16(rcv._tab.Pos+flatbuffers.UOffsetT(12), n)
}

/// Unix timestamp UTC.
func (rcv *Trade) TimestampUtc() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(16))
}
/// Unix timestamp UTC.
func (rcv *Trade) MutateTimestampUtc(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(16), n)
}

func CreateTrade(builder *flatbuffers.Builder, commodityId uint64, units uint32, credits uint16, timestampUtc uint64) flatbuffers.UOffsetT {
	builder.Prep(8, 24)
	builder.PrependUint64(timestampUtc)
	builder.Pad(2)
	builder.PrependUint16(credits)
	builder.PrependUint32(units)
	builder.PrependUint64(commodityId)
	return builder.Offset()
}
type FacilityListing struct {
	_tab flatbuffers.Table
}

func GetRootAsFacilityListing(buf []byte, offset flatbuffers.UOffsetT) *FacilityListing {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FacilityListing{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *FacilityListing) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FacilityListing) Table() flatbuffers.Table {
	return rcv._tab
}

/// Commodities this facility sells.
func (rcv *FacilityListing) Supply(obj *Trade, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 24
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *FacilityListing) SupplyLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Commodities this facility sells.
/// Commodities this facility buys.
func (rcv *FacilityListing) Demand(obj *Trade, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 24
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *FacilityListing) DemandLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Commodities this facility buys.
func FacilityListingStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func FacilityListingAddSupply(builder *flatbuffers.Builder, supply flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(supply), 0)
}
func FacilityListingStartSupplyVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(24, numElems, 8)
}
func FacilityListingAddDemand(builder *flatbuffers.Builder, demand flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(demand), 0)
}
func FacilityListingStartDemandVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(24, numElems, 8)
}
func FacilityListingEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
/// Facility represents a static, dockable entity within the game such as a station or planetary base.
/// Instead of assigning stations their own unique IDs, we produce an fnv1a_32 hash of the system name
/// and the station name.
type Facility struct {
	_tab flatbuffers.Table
}

func GetRootAsFacility(buf []byte, offset flatbuffers.UOffsetT) *Facility {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Facility{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Facility) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Facility) Table() flatbuffers.Table {
	return rcv._tab
}

/// "{upper system name}@{facility name upper}"
func (rcv *Facility) FacilityId() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// "{upper system name}@{facility name upper}"
func (rcv *Facility) MutateFacilityId(n uint32) bool {
	return rcv._tab.MutateUint32Slot(4, n)
}

/// Hash of the all-upper name of the system.
func (rcv *Facility) SystemId() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Hash of the all-upper name of the system.
func (rcv *Facility) MutateSystemId(n uint32) bool {
	return rcv._tab.MutateUint32Slot(6, n)
}

/// Name of the facility itself.
func (rcv *Facility) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Name of the facility itself.
/// Unix timestamp UTC of last update.
func (rcv *Facility) TimestampUtc() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// Unix timestamp UTC of last update.
func (rcv *Facility) MutateTimestampUtc(n uint64) bool {
	return rcv._tab.MutateUint64Slot(10, n)
}

/// Optional facility type.
func (rcv *Facility) FacilityType() FacilityType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetInt8(o + rcv._tab.Pos)
	}
	return 0
}

/// Optional facility type.
func (rcv *Facility) MutateFacilityType(n FacilityType) bool {
	return rcv._tab.MutateInt8Slot(12, n)
}

/// Does it have an accessible trade market.
func (rcv *Facility) HasMarket() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return true
}

/// Does it have an accessible trade market.
func (rcv *Facility) MutateHasMarket(n bool) bool {
	return rcv._tab.MutateBoolSlot(14, n)
}

/// Does it have a black market.
func (rcv *Facility) HasBlackMarket() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Does it have a black market.
func (rcv *Facility) MutateHasBlackMarket(n bool) bool {
	return rcv._tab.MutateBoolSlot(16, n)
}

/// Can it refuel.
func (rcv *Facility) HasRefuel() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return true
}

/// Can it refuel.
func (rcv *Facility) MutateHasRefuel(n bool) bool {
	return rcv._tab.MutateBoolSlot(18, n)
}

/// Can it repair.
func (rcv *Facility) HasRepair() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return true
}

/// Can it repair.
func (rcv *Facility) MutateHasRepair(n bool) bool {
	return rcv._tab.MutateBoolSlot(20, n)
}

/// Can it re-arm.
func (rcv *Facility) HasRearm() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return true
}

/// Can it re-arm.
func (rcv *Facility) MutateHasRearm(n bool) bool {
	return rcv._tab.MutateBoolSlot(22, n)
}

/// Does it sell/upgrade ship components.
func (rcv *Facility) HasOutfitting() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return true
}

/// Does it sell/upgrade ship components.
func (rcv *Facility) MutateHasOutfitting(n bool) bool {
	return rcv._tab.MutateBoolSlot(24, n)
}

/// Can you buy ships here.
func (rcv *Facility) HasShipyard() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Can you buy ships here.
func (rcv *Facility) MutateHasShipyard(n bool) bool {
	return rcv._tab.MutateBoolSlot(26, n)
}

/// Can you dock here (this is taken from EDDB and might be redundant).
func (rcv *Facility) HasDocking() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return true
}

/// Can you dock here (this is taken from EDDB and might be redundant).
func (rcv *Facility) MutateHasDocking(n bool) bool {
	return rcv._tab.MutateBoolSlot(28, n)
}

/// Does the market have regular trading commodities available.
func (rcv *Facility) HasCommodities() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return true
}

/// Does the market have regular trading commodities available.
func (rcv *Facility) MutateHasCommodities(n bool) bool {
	return rcv._tab.MutateBoolSlot(30, n)
}

/// Is it on a planet.
func (rcv *Facility) IsPlanetary() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Is it on a planet.
func (rcv *Facility) MutateIsPlanetary(n bool) bool {
	return rcv._tab.MutateBoolSlot(32, n)
}

/// Distance from the facility to the entry point in the system.
func (rcv *Facility) LsToStar() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Distance from the facility to the entry point in the system.
func (rcv *Facility) MutateLsToStar(n uint32) bool {
	return rcv._tab.MutateUint32Slot(34, n)
}

/// The governance of this station. If not present, assume system's government.
func (rcv *Facility) Government() Government {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetInt8(o + rcv._tab.Pos)
	}
	return 5
}

/// The governance of this station. If not present, assume system's government.
func (rcv *Facility) MutateGovernment(n Government) bool {
	return rcv._tab.MutateInt8Slot(36, n)
}

/// The allegiance of this station. If not present, assume system's allegiance.
func (rcv *Facility) Allegiance() Allegiance {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetInt8(o + rcv._tab.Pos)
	}
	return 4
}

/// The allegiance of this station. If not present, assume system's allegiance.
func (rcv *Facility) MutateAllegiance(n Allegiance) bool {
	return rcv._tab.MutateInt8Slot(38, n)
}

/// Presumably the internal ED identifier for the market here.
func (rcv *Facility) EdMarketId() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// Presumably the internal ED identifier for the market here.
func (rcv *Facility) MutateEdMarketId(n uint64) bool {
	return rcv._tab.MutateUint64Slot(40, n)
}

/// Items available for sale/purchase.
func (rcv *Facility) Trades(obj *FacilityListing, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Facility) TradesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Items available for sale/purchase.
func FacilityStart(builder *flatbuffers.Builder) {
	builder.StartObject(20)
}
func FacilityAddFacilityId(builder *flatbuffers.Builder, facilityId uint32) {
	builder.PrependUint32Slot(0, facilityId, 0)
}
func FacilityAddSystemId(builder *flatbuffers.Builder, systemId uint32) {
	builder.PrependUint32Slot(1, systemId, 0)
}
func FacilityAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(name), 0)
}
func FacilityAddTimestampUtc(builder *flatbuffers.Builder, timestampUtc uint64) {
	builder.PrependUint64Slot(3, timestampUtc, 0)
}
func FacilityAddFacilityType(builder *flatbuffers.Builder, facilityType int8) {
	builder.PrependInt8Slot(4, facilityType, 0)
}
func FacilityAddHasMarket(builder *flatbuffers.Builder, hasMarket bool) {
	builder.PrependBoolSlot(5, hasMarket, true)
}
func FacilityAddHasBlackMarket(builder *flatbuffers.Builder, hasBlackMarket bool) {
	builder.PrependBoolSlot(6, hasBlackMarket, false)
}
func FacilityAddHasRefuel(builder *flatbuffers.Builder, hasRefuel bool) {
	builder.PrependBoolSlot(7, hasRefuel, true)
}
func FacilityAddHasRepair(builder *flatbuffers.Builder, hasRepair bool) {
	builder.PrependBoolSlot(8, hasRepair, true)
}
func FacilityAddHasRearm(builder *flatbuffers.Builder, hasRearm bool) {
	builder.PrependBoolSlot(9, hasRearm, true)
}
func FacilityAddHasOutfitting(builder *flatbuffers.Builder, hasOutfitting bool) {
	builder.PrependBoolSlot(10, hasOutfitting, true)
}
func FacilityAddHasShipyard(builder *flatbuffers.Builder, hasShipyard bool) {
	builder.PrependBoolSlot(11, hasShipyard, false)
}
func FacilityAddHasDocking(builder *flatbuffers.Builder, hasDocking bool) {
	builder.PrependBoolSlot(12, hasDocking, true)
}
func FacilityAddHasCommodities(builder *flatbuffers.Builder, hasCommodities bool) {
	builder.PrependBoolSlot(13, hasCommodities, true)
}
func FacilityAddIsPlanetary(builder *flatbuffers.Builder, isPlanetary bool) {
	builder.PrependBoolSlot(14, isPlanetary, false)
}
func FacilityAddLsToStar(builder *flatbuffers.Builder, lsToStar uint32) {
	builder.PrependUint32Slot(15, lsToStar, 0)
}
func FacilityAddGovernment(builder *flatbuffers.Builder, government int8) {
	builder.PrependInt8Slot(16, government, 5)
}
func FacilityAddAllegiance(builder *flatbuffers.Builder, allegiance int8) {
	builder.PrependInt8Slot(17, allegiance, 4)
}
func FacilityAddEdMarketId(builder *flatbuffers.Builder, edMarketId uint64) {
	builder.PrependUint64Slot(18, edMarketId, 0)
}
func FacilityAddTrades(builder *flatbuffers.Builder, trades flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(19, flatbuffers.UOffsetT(trades), 0)
}
func FacilityStartTradesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func FacilityEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
/// Galactic coordinate for a system.
type Coordinate struct {
	_tab flatbuffers.Struct
}

func (rcv *Coordinate) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Coordinate) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *Coordinate) X() float64 {
	return rcv._tab.GetFloat64(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}
func (rcv *Coordinate) MutateX(n float64) bool {
	return rcv._tab.MutateFloat64(rcv._tab.Pos+flatbuffers.UOffsetT(0), n)
}

func (rcv *Coordinate) Y() float64 {
	return rcv._tab.GetFloat64(rcv._tab.Pos + flatbuffers.UOffsetT(8))
}
func (rcv *Coordinate) MutateY(n float64) bool {
	return rcv._tab.MutateFloat64(rcv._tab.Pos+flatbuffers.UOffsetT(8), n)
}

func (rcv *Coordinate) Z() float64 {
	return rcv._tab.GetFloat64(rcv._tab.Pos + flatbuffers.UOffsetT(16))
}
func (rcv *Coordinate) MutateZ(n float64) bool {
	return rcv._tab.MutateFloat64(rcv._tab.Pos+flatbuffers.UOffsetT(16), n)
}

func CreateCoordinate(builder *flatbuffers.Builder, x float64, y float64, z float64) flatbuffers.UOffsetT {
	builder.Prep(8, 24)
	builder.PrependFloat64(z)
	builder.PrependFloat64(y)
	builder.PrependFloat64(x)
	return builder.Offset()
}
/// System corresponds to an individual Elite-Dangerous star system, akin to a map.
type System struct {
	_tab flatbuffers.Table
}

func GetRootAsSystem(buf []byte, offset flatbuffers.UOffsetT) *System {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &System{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *System) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *System) Table() flatbuffers.Table {
	return rcv._tab
}

/// System ID is it's upper-cased name hashed via fnv1a.
func (rcv *System) SystemId() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// System ID is it's upper-cased name hashed via fnv1a.
func (rcv *System) MutateSystemId(n uint32) bool {
	return rcv._tab.MutateUint32Slot(4, n)
}

/// Unique name of the system.
func (rcv *System) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique name of the system.
/// Position in the galaxy.
func (rcv *System) Position(obj *Coordinate) *Coordinate {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(Coordinate)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Position in the galaxy.
/// Timestamp of the last update to this entry UTC.
func (rcv *System) TimestampUtc() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// Timestamp of the last update to this entry UTC.
func (rcv *System) MutateTimestampUtc(n uint64) bool {
	return rcv._tab.MutateUint64Slot(10, n)
}

func (rcv *System) Power() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Whether anyone lives here.
func (rcv *System) Populated() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return true
}

/// Whether anyone lives here.
func (rcv *System) MutatePopulated(n bool) bool {
	return rcv._tab.MutateBoolSlot(14, n)
}

/// Whether a permit is required to enter the systme.
func (rcv *System) NeedsPermit() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Whether a permit is required to enter the systme.
func (rcv *System) MutateNeedsPermit(n bool) bool {
	return rcv._tab.MutateBoolSlot(16, n)
}

/// Law-Enforcement level of the system.
func (rcv *System) Security() SecurityLevel {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetInt8(o + rcv._tab.Pos)
	}
	return 3
}

/// Law-Enforcement level of the system.
func (rcv *System) MutateSecurity(n SecurityLevel) bool {
	return rcv._tab.MutateInt8Slot(18, n)
}

/// What is the government for the system.
func (rcv *System) GovernmentId() Government {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetInt8(o + rcv._tab.Pos)
	}
	return 5
}

/// What is the government for the system.
func (rcv *System) MutateGovernmentId(n Government) bool {
	return rcv._tab.MutateInt8Slot(20, n)
}

/// Which faction is the system allied to.
func (rcv *System) AllegianceId() Allegiance {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetInt8(o + rcv._tab.Pos)
	}
	return 4
}

/// Which faction is the system allied to.
func (rcv *System) MutateAllegianceId(n Allegiance) bool {
	return rcv._tab.MutateInt8Slot(22, n)
}

/// Guess: Elite Dangerous Internal ID
func (rcv *System) EdAddress() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// Guess: Elite Dangerous Internal ID
func (rcv *System) MutateEdAddress(n uint64) bool {
	return rcv._tab.MutateUint64Slot(24, n)
}

/// Facilities in this system.
func (rcv *System) Facilities(obj *Facility, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *System) FacilitiesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Facilities in this system.
func SystemStart(builder *flatbuffers.Builder) {
	builder.StartObject(12)
}
func SystemAddSystemId(builder *flatbuffers.Builder, systemId uint32) {
	builder.PrependUint32Slot(0, systemId, 0)
}
func SystemAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func SystemAddPosition(builder *flatbuffers.Builder, position flatbuffers.UOffsetT) {
	builder.PrependStructSlot(2, flatbuffers.UOffsetT(position), 0)
}
func SystemAddTimestampUtc(builder *flatbuffers.Builder, timestampUtc uint64) {
	builder.PrependUint64Slot(3, timestampUtc, 0)
}
func SystemAddPower(builder *flatbuffers.Builder, power flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(power), 0)
}
func SystemAddPopulated(builder *flatbuffers.Builder, populated bool) {
	builder.PrependBoolSlot(5, populated, true)
}
func SystemAddNeedsPermit(builder *flatbuffers.Builder, needsPermit bool) {
	builder.PrependBoolSlot(6, needsPermit, false)
}
func SystemAddSecurity(builder *flatbuffers.Builder, security int8) {
	builder.PrependInt8Slot(7, security, 3)
}
func SystemAddGovernmentId(builder *flatbuffers.Builder, governmentId int8) {
	builder.PrependInt8Slot(8, governmentId, 5)
}
func SystemAddAllegianceId(builder *flatbuffers.Builder, allegianceId int8) {
	builder.PrependInt8Slot(9, allegianceId, 4)
}
func SystemAddEdAddress(builder *flatbuffers.Builder, edAddress uint64) {
	builder.PrependUint64Slot(10, edAddress, 0)
}
func SystemAddFacilities(builder *flatbuffers.Builder, facilities flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(facilities), 0)
}
func SystemStartFacilitiesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SystemEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
/// Encapsulation of all the data.
type Galaxy struct {
	_tab flatbuffers.Table
}

func GetRootAsGalaxy(buf []byte, offset flatbuffers.UOffsetT) *Galaxy {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Galaxy{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Galaxy) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Galaxy) Table() flatbuffers.Table {
	return rcv._tab
}

/// Semantically-versioned schema id.
func (rcv *Galaxy) SchemaVersion() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Semantically-versioned schema id.
/// Human-friendly description of what is enclosed, e.g "import from source X" or
/// "complete local database". Entirely descriptive.
func (rcv *Galaxy) Description() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Human-friendly description of what is enclosed, e.g "import from source X" or
/// "complete local database". Entirely descriptive.
/// Human-friendly attributition, if relevant.
func (rcv *Galaxy) Attribution() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Human-friendly attributition, if relevant.
/// UTC Unix time of generation.
func (rcv *Galaxy) TimestampUtc() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

/// UTC Unix time of generation.
func (rcv *Galaxy) MutateTimestampUtc(n uint64) bool {
	return rcv._tab.MutateUint64Slot(10, n)
}

/// Items recognized by this data.
func (rcv *Galaxy) Commodities(obj *Commodity, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Galaxy) CommoditiesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Items recognized by this data.
/// Systems recognized by this data (presence of facilities optional).
func (rcv *Galaxy) Systems(obj *System, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Galaxy) SystemsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Systems recognized by this data (presence of facilities optional).
/// Fields reserved for any user-specific notes.
func (rcv *Galaxy) UserData() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Fields reserved for any user-specific notes.
/// 3rd-party application values that prefer .ini format.
func (rcv *Galaxy) IniData() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// 3rd-party application values that prefer .ini format.
/// 3rd-party application values that prefer .json format.
func (rcv *Galaxy) JsonData() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// 3rd-party application values that prefer .json format.
/// 3rd-party application values that prefer .yaml because they hate life.
func (rcv *Galaxy) YamlData() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// 3rd-party application values that prefer .yaml because they hate life.
func GalaxyStart(builder *flatbuffers.Builder) {
	builder.StartObject(10)
}
func GalaxyAddSchemaVersion(builder *flatbuffers.Builder, schemaVersion flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(schemaVersion), 0)
}
func GalaxyAddDescription(builder *flatbuffers.Builder, description flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(description), 0)
}
func GalaxyAddAttribution(builder *flatbuffers.Builder, attribution flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(attribution), 0)
}
func GalaxyAddTimestampUtc(builder *flatbuffers.Builder, timestampUtc uint64) {
	builder.PrependUint64Slot(3, timestampUtc, 0)
}
func GalaxyAddCommodities(builder *flatbuffers.Builder, commodities flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(commodities), 0)
}
func GalaxyStartCommoditiesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GalaxyAddSystems(builder *flatbuffers.Builder, systems flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(systems), 0)
}
func GalaxyStartSystemsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GalaxyAddUserData(builder *flatbuffers.Builder, userData flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(userData), 0)
}
func GalaxyAddIniData(builder *flatbuffers.Builder, iniData flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(iniData), 0)
}
func GalaxyAddJsonData(builder *flatbuffers.Builder, jsonData flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(jsonData), 0)
}
func GalaxyAddYamlData(builder *flatbuffers.Builder, yamlData flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(yamlData), 0)
}
func GalaxyEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
